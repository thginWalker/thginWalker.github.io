<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[常用DOS命令]]></title>
      <url>/8.html/</url>
      <content type="html"><![CDATA[<p>就个人而言，DOS是我所一直喜欢的，至始至终。但是没有系统化、专业化的学习也许终究是可悲的。<br><a id="more"></a><br>很多DOS命令是学习黑客技术的基础，也就是说掌握这些基础知识是必不可少的。<br>也许对于下面的命令我是该好好了解下了:</p>
<ul>
<li>net命令</li>
<li>远程登录telent命令</li>
<li>文件传输ftp命令</li>
<li>添加计划任务at命令(从win8起已经废除)改schtasks命令</li>
<li>查看修改文件夹权限cacls命令</li>
<li>回显echo命令</li>
<li>命令行下的注册表操作</li>
<li>查看当前系统用户情况query命令</li>
<li>终止会话logoff命令</li>
<li>物理网络查看ping命令</li>
<li>网络配置查询ipconfig命令</li>
<li>查看通信路由tracert命令</li>
<li>DNS查看nslook up(不是内部或外部命令)</li>
<li>地址解析arp命令</li>
<li>诊断nbtstat命令</li>
<li>netstat命令</li>
<li>rcp命令</li>
<li>rexec命令</li>
<li>route命令</li>
<li>rsh命令</li>
<li>tftp命令</li>
</ul>
<h3 id="命令解析"><a href="#命令解析" class="headerlink" title="命令解析"></a>命令解析</h3><p>谁叫我也不太了解呢，只能一个个用来学习了。</p>
<h4 id="net命令"><a href="#net命令" class="headerlink" title="net命令"></a>net命令</h4><p>net命令被称为功能强大的以命令行方式执行的感觉，它包含了管理网络环境、服务、用户、登录等windows 98/NT/2000中大部分重要的管理功能。</p>
<p>使用它可以管理本地或者远程计算机的网络环境，以及各种服务程序的运行和配置。或者进行用户管理和登陆管理等。</p>
<h5 id="net-view和net-use"><a href="#net-view和net-use" class="headerlink" title="net view和net use"></a>net view和net use</h5><p>其中最常用的是<code>net view</code>和<code>net use</code>，通过这两个命令，可以连接网络上开发了远程共享的系统，并且获得资料，这种远程共享本来是为便捷操作设计，但是很多网络管理员忽略了它的安全性，所有造成了很多不应该共享的信息的暴露，可以让入侵者轻易地获得计算机的隐私资料，具体的命令如下:<br>建立IPC空连接:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">net use \\ip地址 &quot;&quot; /user:&quot;&quot;</div></pre></td></tr></table></figure></p>
<p>建立IPC连接:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">net use \\192.168.0.1\\ipc$ &quot;12345&quot; /user:admin</div></pre></td></tr></table></figure></p>
<p>(假设IP为192.168.0.1,密码12345,用户名admin)<br>删除IPC连接:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">net use \\192.168.0.1\ipc$\del</div></pre></td></tr></table></figure></p>
<p>当然对于这两个命令需要深入研究:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">net view \\ip           //查看开了那些共享</div><div class="line">net view x: \\ip\sharp  //把共享映射为本地X盘</div></pre></td></tr></table></figure></p>
<h5 id="启动和关闭服务"><a href="#启动和关闭服务" class="headerlink" title="启动和关闭服务"></a>启动和关闭服务</h5><p>服务我就不多说了。<br>启动服务:<code>net start 服务名</code><br>关闭服务:<code>net stop 服务名</code></p>
<h5 id="启动和关闭共享"><a href="#启动和关闭共享" class="headerlink" title="启动和关闭共享"></a>启动和关闭共享</h5><p>计算机内部的共享资源的操作<br>启动共享:<code>net share 共享名</code><br>关闭共享:<code>net share 共享名/del</code><br>查看共享:<code>net share</code></p>
<h5 id="映射磁盘和删除映射磁盘"><a href="#映射磁盘和删除映射磁盘" class="headerlink" title="映射磁盘和删除映射磁盘"></a>映射磁盘和删除映射磁盘</h5><p>映射磁盘就是将其他的计算机盘符映射到本地磁盘<br>映射磁盘:<code>net use z:\192.168.0.1\c$</code><br>将受害者系统开放的默认共享C盘映射为自己的本地磁盘z，操作自己的z盘就想操作它的c盘。<br>注意:建立磁盘映射必须先建立IPC连接，要映射成的磁盘必须是本地不存在的盘符。<br>删除映射:<code>net use z:/del</code></p>
<h5 id="查看远程系统的时间"><a href="#查看远程系统的时间" class="headerlink" title="查看远程系统的时间"></a>查看远程系统的时间</h5><p><code>net time\IP</code></p>
<h5 id="添加和删除用户"><a href="#添加和删除用户" class="headerlink" title="添加和删除用户"></a>添加和删除用户</h5><p>查看用户:<code>net user</code><br>添加用户:<code>net user 用户名 密码 /add</code><br>删除用户:<code>net user 用户名 /del</code></p>
<h5 id="添加和删除到管理员组"><a href="#添加和删除到管理员组" class="headerlink" title="添加和删除到管理员组"></a>添加和删除到管理员组</h5><p>添加用户:<code>net localgroup administrators 用户名 /add</code><br>删除用户:<code>net localgroup administrators 用户名 /del</code></p>
<h5 id="激活和禁止guest账号"><a href="#激活和禁止guest账号" class="headerlink" title="激活和禁止guest账号"></a>激活和禁止guest账号</h5><p>激活guest:<code>net user guest /active:yes</code><br>禁止guest:<code>net user guest /del</code></p>
<h4 id="远程登录telnet命令"><a href="#远程登录telnet命令" class="headerlink" title="远程登录telnet命令"></a>远程登录telnet命令</h4><p>这个命令是用来远程连接的，但是默认为关闭需要打开。<br>格式:telnet IP port<br>telnet 192.168.0.1 1234<br>连接到192.168.0.1的1234端口，telnet的默认端口是23<br>条件:受害者开启<code>23</code>端口并且不使用<code>NTLM</code>验证。</p>
<h4 id="文件传输ftp命令"><a href="#文件传输ftp命令" class="headerlink" title="文件传输ftp命令"></a>文件传输ftp命令</h4><p>ftp进行文件的传输。<br>该命令最基本的是<code>ftp IP</code><br>在输入用户名和密码之后就可以使用get或者put来进行下载和上传操作。<br>使用disconnect断开连接，bye或者quit退出FTP。</p>
<h4 id="添加计划任务at命令-从win8起已经废除-改schtasks命令"><a href="#添加计划任务at命令-从win8起已经废除-改schtasks命令" class="headerlink" title="添加计划任务at命令(从win8起已经废除)改schtasks命令"></a>添加计划任务at命令(从win8起已经废除)改schtasks命令</h4><p>注:这些命令都不完善，在此我只是提供关键字，更多操作需要时google即可。<br>安排命令和程序定期运行或在指定时间内运行。从计划表中添加和删除任务，按需要启动和停止任务，显示和更改计划任务。</p>
<h5 id="创建新的计划任务"><a href="#创建新的计划任务" class="headerlink" title="创建新的计划任务"></a>创建新的计划任务</h5><p><code>schtasks /create</code></p>
<h5 id="删除计划任务"><a href="#删除计划任务" class="headerlink" title="删除计划任务"></a>删除计划任务</h5><p><code>schtasks  /Delete</code>         </p>
<h5 id="显示所有计划任务。"><a href="#显示所有计划任务。" class="headerlink" title="显示所有计划任务。"></a>显示所有计划任务。</h5><p><code>schtasks    /Query</code>    </p>
<h5 id="更改计划任务属性。"><a href="#更改计划任务属性。" class="headerlink" title="更改计划任务属性。"></a>更改计划任务属性。</h5><p><code>schtasks    /Change</code>   </p>
<h5 id="按需运行计划任务。"><a href="#按需运行计划任务。" class="headerlink" title="按需运行计划任务。"></a>按需运行计划任务。</h5><p><code>schtasks    /Run</code>   </p>
<h5 id="中止当前正在运行的计划任务。"><a href="#中止当前正在运行的计划任务。" class="headerlink" title="中止当前正在运行的计划任务。"></a>中止当前正在运行的计划任务。</h5><p><code>schtasks   /End</code></p>
<h5 id="显示与计划的任务名称相应的安全标识符。"><a href="#显示与计划的任务名称相应的安全标识符。" class="headerlink" title="显示与计划的任务名称相应的安全标识符。"></a>显示与计划的任务名称相应的安全标识符。</h5><p><code>schtasks    /ShowSid</code>       </p>
<h4 id="查看修改文件夹权限cacls命令"><a href="#查看修改文件夹权限cacls命令" class="headerlink" title="查看修改文件夹权限cacls命令"></a>查看修改文件夹权限cacls命令</h4><p>注意:不推荐使用 Cacls，请使用 Icacls</p>
<h4 id="回显echo命令"><a href="#回显echo命令" class="headerlink" title="回显echo命令"></a>回显echo命令</h4><p>也就是输出命令<br><code>echo “输出内容”</code></p>
<h4 id="命令行下的注册表操作"><a href="#命令行下的注册表操作" class="headerlink" title="命令行下的注册表操作"></a>命令行下的注册表操作</h4><h4 id="查看当前系统用户情况query命令"><a href="#查看当前系统用户情况query命令" class="headerlink" title="查看当前系统用户情况query命令"></a>查看当前系统用户情况query命令</h4><p>使用<code>query user</code>可以查看当前系统的会话，比如查看是否有人使用远程终端登录服务器<br>使用<code>query</code>可以查看到某用户的<code>session</code>，然后通过<code>logoff</code>命令将其踢出去。</p>
<h4 id="终止会话logoff命令"><a href="#终止会话logoff命令" class="headerlink" title="终止会话logoff命令"></a>终止会话logoff命令</h4><p>logoff用法help即可，然后通过<code>logoff</code>命令将其它管理员和用户踢出去。</p>
<h4 id="物理网络查看ping命令"><a href="#物理网络查看ping命令" class="headerlink" title="物理网络查看ping命令"></a>物理网络查看ping命令</h4><p>命令ping我觉得最大的用处就是看远程计算机IP是否可以正常访问吧!<br>ping命令可以检测数据包在哪一个节点之后出现了问题，也可以判断对方是windows系统还是linux系统。(不过并不太可靠)<br>还是可以得到目的网站的IP地址。</p>
<h4 id="网络配置查询ipconfig命令"><a href="#网络配置查询ipconfig命令" class="headerlink" title="网络配置查询ipconfig命令"></a>网络配置查询ipconfig命令</h4><p>使用ipconfig/all命令可以方便地查看网卡的MAC地址、主机的网络设置等，在向内网渗透的过程中，需要了解受害者的网络配置，可以使用ipconfig来查看。</p>
<h4 id="查看通信路由tracert命令"><a href="#查看通信路由tracert命令" class="headerlink" title="查看通信路由tracert命令"></a>查看通信路由tracert命令</h4><p>tracert是路由跟踪程序，用于确定IP数据报访问目标所经过的路径。<br>具体功暂时我也不太清楚理解，以后补充！</p>
<h4 id="DNS查看nslookup命令"><a href="#DNS查看nslookup命令" class="headerlink" title="DNS查看nslookup命令"></a>DNS查看nslookup命令</h4><p>使用nslookup可以查看主机的DNS服务器，nslookup最简单的用户用法就是查询域名</p>
<h4 id="地址解析arp命令"><a href="#地址解析arp命令" class="headerlink" title="地址解析arp命令"></a>地址解析arp命令</h4><h4 id="诊断nbtstat命令"><a href="#诊断nbtstat命令" class="headerlink" title="诊断nbtstat命令"></a>诊断nbtstat命令</h4><h4 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h4><h4 id="rcp命令"><a href="#rcp命令" class="headerlink" title="rcp命令"></a>rcp命令</h4><h4 id="rexec命令"><a href="#rexec命令" class="headerlink" title="rexec命令"></a>rexec命令</h4><h4 id="route命令"><a href="#route命令" class="headerlink" title="route命令"></a>route命令</h4><h4 id="rsh命令"><a href="#rsh命令" class="headerlink" title="rsh命令"></a>rsh命令</h4><h4 id="tftp命令"><a href="#tftp命令" class="headerlink" title="tftp命令"></a>tftp命令</h4><p><strong>以上就是对常用DOS命令的小小见解。</strong></p>
]]></content>
      
        <categories>
            
            <category> 网络攻防 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[菜鸟使用树莓派进行简易人脸识别(二)]]></title>
      <url>/7.html/</url>
      <content type="html"><![CDATA[<p>学习了Demo里面的基础知识后，看样子是需要真正来理解Python项目中的代码了。<br><a id="more"></a><br><a href="http://blog.csdn.net/jireren/article/details/52167791" target="_blank" rel="external">代码Demo参考</a><br>当然这只是一个理解代码的文章。所以贴出代码吧!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">### 导入库 ###</div><div class="line"></div><div class="line">from picamera.array import PiRGBArray</div><div class="line">from picamera import PiCamera</div><div class="line">import time</div><div class="line">import cv2</div><div class="line">import os</div><div class="line"></div><div class="line"></div><div class="line">### 安装程序 ###</div><div class="line"></div><div class="line"># 中心坐标</div><div class="line">cx = 160</div><div class="line">cy = 120</div><div class="line"></div><div class="line">os.system( &quot;echo 0=150 &gt; /dev/servoblaster&quot; )</div><div class="line">os.system( &quot;echo 1=150 &gt; /dev/servoblaster&quot; )</div><div class="line"></div><div class="line">xdeg = 150</div><div class="line">ydeg = 150</div><div class="line"></div><div class="line"># 设置相机</div><div class="line">camera = PiCamera()</div><div class="line">camera.resolution = ( 320, 240 )</div><div class="line">camera.framerate = 60</div><div class="line">rawCapture = PiRGBArray( camera, size=( 320, 240 ) )</div><div class="line"></div><div class="line"># 加载一个级联文件，用于检测人脸</div><div class="line">face_cascade = cv2.CascadeClassifier( &apos;/home/pi/opencv-2.4.9/data/lbpcascades/lbpcascade_frontalface.xml&apos; ) </div><div class="line"></div><div class="line">t_start = time.time()</div><div class="line">fps = 0</div><div class="line"></div><div class="line"></div><div class="line">### 主函数 ###</div><div class="line"></div><div class="line"># 从相机捕捉帧</div><div class="line">for frame in camera.capture_continuous( rawCapture, format=&quot;bgr&quot;, use_video_port=True ):</div><div class="line"></div><div class="line">    image = frame.array</div><div class="line"></div><div class="line">    # 使用我们加载的级联文件来检测人脸 </div><div class="line">    gray = cv2.cvtColor( image, cv2.COLOR_BGR2GRAY )</div><div class="line">    faces = face_cascade.detectMultiScale( gray )</div><div class="line"></div><div class="line">    print &quot;Found &quot; + str( len( faces ) ) + &quot; face(s)&quot;</div><div class="line"></div><div class="line">    # 画一个矩形在每一个脸和移动电机面对</div><div class="line">    for ( x, y, w, h ) in faces:</div><div class="line"></div><div class="line">        cv2.rectangle( image, ( x, y ), ( x + w, y + h ), ( 100, 255, 100 ), 2 )</div><div class="line">        cv2.putText( image, &quot;Face No.&quot; + str( len( faces ) ), ( x, y ), cv2.FONT_HERSHEY_SIMPLEX, 0.5, ( 0, 0, 255 ), 2 )</div><div class="line"></div><div class="line">        tx = x + w/2</div><div class="line">        ty = y + h/2</div><div class="line"></div><div class="line">        if   ( cx - tx &gt;  10 and xdeg &lt;= 190 ):</div><div class="line">            xdeg += 3</div><div class="line">            os.system( &quot;echo 0=&quot; + str( xdeg ) + &quot; &gt; /dev/servoblaster&quot; )</div><div class="line">        elif ( cx - tx &lt; -10 and xdeg &gt;= 110 ):</div><div class="line">            xdeg -= 3</div><div class="line">            os.system( &quot;echo 0=&quot; + str( xdeg ) + &quot; &gt; /dev/servoblaster&quot; )</div><div class="line"></div><div class="line">        if   ( cy - ty &gt;  10 and ydeg &gt;= 110 ):</div><div class="line">            ydeg -= 3</div><div class="line">            os.system( &quot;echo 1=&quot; + str( ydeg ) + &quot; &gt; /dev/servoblaster&quot; )</div><div class="line">        elif ( cy - ty &lt; -10 and ydeg &lt;= 190 ):</div><div class="line">            ydeg += 3</div><div class="line">            os.system( &quot;echo 1=&quot; + str( ydeg ) + &quot; &gt; /dev/servoblaster&quot; )</div><div class="line"></div><div class="line">    # 计算并显示FPS</div><div class="line">    fps = fps + 1</div><div class="line">    sfps = fps / ( time.time() - t_start )</div><div class="line">    cv2.putText( image, &quot;FPS : &quot; + str( int( sfps ) ), ( 10, 10 ), cv2.FONT_HERSHEY_SIMPLEX, 0.5, ( 0, 0, 255 ), 2 )    </div><div class="line"></div><div class="line">    # 展示框架</div><div class="line">    cv2.imshow( &quot;Frame&quot;, image )</div><div class="line">    cv2.waitKey( 1 )</div><div class="line"></div><div class="line">    # 在准备下一帧时清除流</div><div class="line">    rawCapture.truncate( 0 )</div></pre></td></tr></table></figure></p>
<p>这是原代码，只不过我将注释换成了中文了，方便阅读吧。<br>现在我需要做的就是理解没一行代码，就是这样无奈~~~~</p>
<p><strong>以上就是对人脸识别的小小见解。</strong></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[菜鸟使用树莓派进行简易人脸识别(一)]]></title>
      <url>/6.html/</url>
      <content type="html"><![CDATA[<p>机缘巧合下参与了人工智能工作室项目”树莓派进行人脸识别”，因此可以好好研究一下Python了。<br><a id="more"></a><br>对于Python，只能既爱又恨了。爱的是Python的强大，恨的是可惜看了几本书没能学好Python的开发。原因也是有的，不敲代码看书就是没毛用。<br>不过这次”树莓派进行人脸识别”项目负责软件代码方面，所以必须认真理解代码学习Python。<br><a href="http://blog.csdn.net/jireren/article/details/52167791" target="_blank" rel="external">代码Demo参考</a><br>当然第一次接触这个Demo并没有认真理解清楚，所以我进行了以下的工作:</p>
<ul>
<li>介绍树莓派</li>
<li>手把手教你如何用 OpenCV + Python 实现人脸识别</li>
<li>Python OS模块常用功能中文图文详解</li>
<li>Python time模块学习</li>
<li>Python模块picamera</li>
</ul>
<h4 id="介绍树莓派"><a href="#介绍树莓派" class="headerlink" title="介绍树莓派"></a>介绍树莓派</h4><p><a href="http://baike.baidu.com/link?url=1WYrsq-uzPIqoXV6iZdRRLFdj-uLNZve6RJycGpVOM8pj6wbjaT6qkhRH1ZPMDB80il5YbXR4WruUZZJuOQkO_8U1t9AIeTnO823KkIK6fxAPPIY4c3dqMWgwpw06_PB" target="_blank" rel="external">借鉴</a><br>树莓派是一个职业信用卡大小的裸露电路板，它也是一个运行linux操作系统的完全可编程的PC系统。<br>当然在此，我们可以了解到可以完成大部分电脑能完成的事情:<code>编辑office文档</code>、<code>浏览网页</code>、<code>玩游戏</code>。<br>当然设置它的配件:<code>SD卡(预装系统)</code>、<code>USB键盘和鼠标</code>、<code>显示器</code>、<code>WiFi适配器(USB无线网卡)</code>…..其他就不说了，对硬件不感冒。<br>当然安装操作系统<br>准备工作和安装实战百科说的比较好哦！可以借鉴其他的。<br>启动成功的景象:</p>
<p><img src="/6.html/5d6034a85edf8db125dae65c0823dd54564e7416.jpg" alt="启动图片"><br>不要说对树莓派没什么了解，说实话，在写这篇博客之前我也从未接触过它，不过并不担心我们对它的了解。</p>
<h5 id="手把手教你如何用-OpenCV-Python-实现人脸识别"><a href="#手把手教你如何用-OpenCV-Python-实现人脸识别" class="headerlink" title="手把手教你如何用 OpenCV + Python 实现人脸识别"></a>手把手教你如何用 OpenCV + Python 实现人脸识别</h5><p><a href="http://www.leiphone.com/news/201704/rYdpAvh4SvgVPpRQ.html" target="_blank" rel="external">借鉴</a><br>这篇文章理解还是较简单的。无非三步:</p>
<ul>
<li>OpenCV的Python环境搭建</li>
<li>相关知识储备</li>
<li>代码的实现人脸识别</li>
</ul>
<h5 id="OpenCV的Python环境搭建"><a href="#OpenCV的Python环境搭建" class="headerlink" title="OpenCV的Python环境搭建"></a>OpenCV的Python环境搭建</h5><p><a href="http://blog.csdn.net/marksinoberg/article/details/52442229" target="_blank" rel="external">借鉴</a><br>对于菜鸟的我来说，先了解<code>OpenCV</code>要紧，没办法<code>百科</code>了个答案：<br>大概意思就是OpenCv是一个跨平台计算机视觉库。用C++编写实现的一些功能的。<br>笼统的说吧就是它可以进行<code>图像处理</code>和<code>视觉</code>操作，也就是让计算机有部分<code>视觉功能</code>吧!<br>当然今天我们主要使用<code>Python</code>来使用它。<br>首先只能安装OpenCV了，只能使用<code>pip</code>,什么还没安装，我也没有哦，看<a href="http://blog.csdn.net/u010128736/article/details/52713204" target="_blank" rel="external">借鉴</a>吧。</p>
<h5 id="相关知识储备"><a href="#相关知识储备" class="headerlink" title="相关知识储备"></a>相关知识储备</h5><p>Haar特征值反映了图像的灰度变化情况。<br>例如：脸部的一些特征能由矩形特征简单的描述，如：眼睛要比脸颊颜色要深，鼻梁两侧比鼻梁颜色要深，嘴巴比周围颜色要深等。<br><code>opencv api</code><br>要想使用opencv，就必须先知道其能干什么，怎么做。于是API的重要性便体现出来了。就本例而言，使用到的函数很少，也就普通的读取图片，灰度转换，显示图像，简单的编辑图像罢了。<br><code>读取图片</code><br>只需要给出待操作的图片的路径即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">image = cv2.imread(imagepath)</div></pre></td></tr></table></figure></p>
<p><code>灰度转换</code><br>灰度转换的作用就是：转换成灰度的图片的计算强度得以降低。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">gray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)</div></pre></td></tr></table></figure></p>
<p><code>画图</code><br>opencv 的强大之处的一个体现就是其可以对图片进行任意编辑，处理。 下面的这个函数最后一个参数指定的就是画笔的大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">cv2.rectangle(image,(x,y),(x+w,y+w),(0,255,0),2)</div></pre></td></tr></table></figure></p>
<p><code>显示图像</code><br>编辑完的图像要么直接的被显示出来，要么就保存到物理的存储介质。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">cv2.imshow(&quot;Image Title&quot;,image)</div></pre></td></tr></table></figure></p>
<p><code>获取人脸识别训练数据</code><br>看似复杂，其实就是对于人脸特征的一些描述，这样opencv在读取完数据后很据训练中的样品数据，就可以感知读取到的图片上的特征，进而对图片进行人脸识别。<br>这里卖弄的这个xml文件，就是opencv在GitHub上共享出来的具有普适的训练好的数据。我们可以直接的拿来使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">face_cascade = cv2.CascadeClassifier(r&apos;./haarcascade_frontalface_default.xml&apos;)</div></pre></td></tr></table></figure></p>
<p><code>探测人脸</code><br>说白了，就是根据训练的数据来对新图片进行识别的过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"># 探测图片中的人脸</div><div class="line">faces = face_cascade.detectMultiScale(</div><div class="line">    gray,</div><div class="line">    scaleFactor = 1.15,</div><div class="line">    minNeighbors = 5,</div><div class="line">    minSize = (5,5),</div><div class="line">    flags = cv2.cv.CV_HAAR_SCALE_IMAGE</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>我们可以随意的指定里面参数的值，来达到不同精度下的识别。返回值就是opencv对图片的探测结果的体现。</p>
<p><code>处理人脸探测的结果</code><br>结束了刚才的人脸探测，我们就可以拿到返回值来做进一步的处理了。但这也不是说会多么的复杂，无非添加点特征值罢了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">print &quot;发现&#123;0&#125;个人脸!&quot;.format(len(faces))</div><div class="line">for(x,y,w,h) in faces:</div><div class="line">   cv2.rectangle(image,(x,y),(x+w,y+w),(0,255,0),2)</div></pre></td></tr></table></figure></p>
<h5 id="代码的实现人脸识别"><a href="#代码的实现人脸识别" class="headerlink" title="代码的实现人脸识别"></a>代码的实现人脸识别</h5><p><img src="http://static.leiphone.com/uploads/new/article/740_740/201704/5903040bf4146.jpg?imageMogr2/format/jpg/quality/90" alt="图片素材"></p>
<p>具体代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"># coding:utf-8</div><div class="line">import sys</div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(&apos;utf8&apos;)</div><div class="line">import cv2</div><div class="line"># 待检测的图片路径</div><div class="line">imagepath = r&apos;./heat.jpg&apos;</div><div class="line"># 获取训练好的人脸的参数数据，这里直接从GitHub上使用默认值</div><div class="line">face_cascade = cv2.CascadeClassifier(r&apos;./haarcascade_frontalface_default.xml&apos;)</div><div class="line"># 读取图片</div><div class="line">image = cv2.imread(imagepath)</div><div class="line">gray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)</div><div class="line"># 探测图片中的人脸</div><div class="line">faces = face_cascade.detectMultiScale(</div><div class="line">    gray,</div><div class="line">    scaleFactor = 1.15,</div><div class="line">    minNeighbors = 5,</div><div class="line">    minSize = (5,5),</div><div class="line">    flags = cv2.cv.CV_HAAR_SCALE_IMAGE</div><div class="line">)</div><div class="line">print &quot;发现&#123;0&#125;个人脸!&quot;.format(len(faces))</div><div class="line">for(x,y,w,h) in faces:</div><div class="line">    # cv2.rectangle(image,(x,y),(x+w,y+w),(0,255,0),2)</div><div class="line">    cv2.circle(image,((x+x+w)/2,(y+y+h)/2),w/2,(0,255,0),2)</div><div class="line">cv2.imshow(&quot;Find Faces!&quot;,image)</div><div class="line">cv2.waitKey(0)</div></pre></td></tr></table></figure></p>
<p>输出结果:<br><img src="https://static.leiphone.com/uploads/new/article/740_740/201704/5903046d63e12.jpg?imageMogr2/format/jpg/quality/90" alt="输出结果"></p>
<p>代码理解:<br>就个人而言，上述代码在我的<code>IDE</code>里面运行时绝对有错误的。<br>不过嘛，有幸我还是完成的这个小小案例。<br>所有先贴上自己代码，然后就不用理解了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"># coding:utf-8</div><div class="line">import sys</div><div class="line">#reload(sys)</div><div class="line">#sys.setdefaultencoding(&apos;utf8&apos;)</div><div class="line">type = sys.getfilesystemencoding() #处理字符编码进行修改</div><div class="line"></div><div class="line">import cv2</div><div class="line">imagepath = r&apos;./1.jpg&apos;# 待检测的图片路径</div><div class="line"></div><div class="line"># 获取训练好的人脸的参数数据，这里直接从GitHub上使用默认值</div><div class="line">face_cascade = cv2.CascadeClassifier(r&apos;./haarcascade_frontalface_default.xml&apos;)</div><div class="line"></div><div class="line"># 读取图片</div><div class="line">image = cv2.imread(imagepath) </div><div class="line">gray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)#灰化</div><div class="line"></div><div class="line"></div><div class="line">###探测图片中的人脸</div><div class="line">faces = face_cascade.detectMultiScale(</div><div class="line">    gray,#进行检测的图像，这里是转换后的</div><div class="line">    scaleFactor = 1.15,#距离相机不同的距离</div><div class="line">    minNeighbors = 5,#对检测点周边多少有效点</div><div class="line">    minSize = (5,5),#检测点的最小值，或者说就是检测点的最终值</div><div class="line">   #这个参数在新版的opencv是不需要的,暂时不管了,注释掉同样可以 </div><div class="line">   #flags = cv2.cv.CV_HAAR_SCALE_IMAGE#相反不1注释却有错</div><div class="line">)</div><div class="line">#设置参数，达到识别。返回值就是opencv对图片的探测结果的体现。</div><div class="line">print &quot;发现&#123;0&#125;个人脸！&quot;.decode(&apos;utf-8&apos;).encode(type).format(len(faces)) #记住人脸的数量</div><div class="line"></div><div class="line">for(x,y,w,h) in faces:</div><div class="line">    cv2.circle(image,((x+x+w)/2,(y+y+h)/2),w/2,(0,255,0),2)</div><div class="line">    #循环对人脸图片进行描绘</div><div class="line">  </div><div class="line">######个人测试数据</div><div class="line">#x = 150</div><div class="line">#y = 150</div><div class="line">#w = 150</div><div class="line">#######个人测试数据</div><div class="line">#cv2.rectangle(image,(x,y),(x+w,y+w),(0,255,0),2)# </div><div class="line">#######个人测试数据</div><div class="line"></div><div class="line"></div><div class="line">cv2.imshow(&quot;find image&quot;,image)#展现图片</div><div class="line">cv2.waitKey(0)#waitKey(0)表示这一帧在你按下任意键前始终显示</div></pre></td></tr></table></figure></p>
<p>没办法个人代码就是这样，应该可以理解了。<br>查看可<a href="https://my.oschina.net/chinesezhx/blog/520917" target="_blank" rel="external">借鉴</a></p>
<h4 id="Python-OS模块常用功能中文图文详解"><a href="#Python-OS模块常用功能中文图文详解" class="headerlink" title="Python OS模块常用功能中文图文详解"></a>Python OS模块常用功能中文图文详解</h4><p><a href="http://www.iplaypy.com/module/os.html" target="_blank" rel="external">借鉴</a><br> OS模块在我的理解中他就类似于其他语言的文件处理模块吧，无非一些函数接口让你可以操作文件和目录，是不是很酷。<br> 对于os我先不多介绍，只说明程序中需要理解的代码和基础模块而已。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import os #导入os模块</div><div class="line">print os.getcwd()  #获取当前路径</div><div class="line">print os.listdir(&apos;/home/wwwroot&apos;) #列出目录下所有文件和文件夹</div><div class="line">print os.mkdir(&apos;heihei&apos;) #创建一个heihei的目录</div><div class="line">print os.rmdir(&apos;abc&apos;) #删除一个abc目录</div><div class="line">print os.rename(&apos;abc.txt&apos;,&apos;readme.txt&apos;) #重命名一个文件</div></pre></td></tr></table></figure></p>
<p>话说和linux命令查这么像呢，不管了。</p>
<h4 id="Python-time模块学习"><a href="#Python-time模块学习" class="headerlink" title="Python time模块学习"></a>Python time模块学习</h4><p><a href="http://python.jobbole.com/85491/" target="_blank" rel="external">借鉴</a><br>time模块是用于管理时间和日期的C库函数，这是因为它绑定到底层C实现，所有一些细节会基于具体的平台而不同。<br>说时间对于语言的时间我觉得就是烦，所有还是粗略了解。</p>
<ul>
<li><p>time()<br>返回纪元开始的秒数，返回为浮点数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;import time</div><div class="line">&gt;&gt;&gt;time.time()</div><div class="line">1495020286.013</div></pre></td></tr></table></figure>
</li>
<li><p>ctime()<br>返回友好的人类时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;import time</div><div class="line">&gt;&gt;&gt;time.ctime()</div><div class="line">&apos;Wed May 17 19:27:21 2017&apos;</div></pre></td></tr></table></figure>
</li>
<li><p>struct_time()<br>用这个可以分开存储时间的各个部分，感觉对我可爱极了。<br>gmtime()用于获取UTC(格林尼治)时间，localtime()用于获取当前时区的当前时间。</p>
</li>
<li>sleep()<br>说实话，这个就相当于定时器，规定间隔多长时间在运行下面代码。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import time</div><div class="line">time.sleep(5)</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Python模块picamera"><a href="#Python模块picamera" class="headerlink" title="Python模块picamera"></a>Python模块picamera</h4><p><a href="https://my.oschina.net/surenpi/blog/605526" target="_blank" rel="external">借鉴</a><br>单独理解<code>picamera</code>我还真不知道是什么，也可能就仅仅是一个Python模块吧！而它是用来操作树莓派摄像头的。<br>它的更多<a href="http://picamera.readthedocs.org/en/release-1.2/api.html" target="_blank" rel="external">API介绍</a><br>当然在此我还是不去深究那强悍的API介绍了。</p>
<hr>
<p>需修改</p>
<p><code>最简单的拍照</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[codesyntax lang=&quot;python&quot;]</div><div class="line"></div><div class="line">!/usr/bin/python</div><div class="line"># from http://surenpi.com</div><div class="line"># raspberry camera python example</div><div class="line"></div><div class="line">import picamera</div><div class="line">import time</div><div class="line"></div><div class="line">cam = picamera.PiCamera()</div><div class="line">cam.vflip = True</div><div class="line">cam.capture(&apos;a.jpg&apos;)</div><div class="line">cam.close()</div><div class="line"></div><div class="line">print &apos;capture done.&apos;</div></pre></td></tr></table></figure></p>
<p>[/codesyntax]</p>
<p><code>录制视频</code></p>
<p>可以将视频保存到文件中或者其他地方，默认录制的时候是不会有预览的，可以通过调用start_preview函数来预览 [codesyntax lang=”python”]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import picamera</div><div class="line"></div><div class="line">with picamera.PiCamera() as camera:</div><div class="line">	camera.resolution = (640, 480)</div><div class="line">	camera.start_preview()</div><div class="line"></div><div class="line">	camera.start_recording(&apos;suren.h264&apos;, format=&apos;h264&apos;, quantization=23, resize=(1024, 768))</div><div class="line">	camera.wait_recording(60)</div><div class="line">	camera.stop_recording()</div><div class="line"></div><div class="line">	camera.stop_preview()</div></pre></td></tr></table></figure></p>
<p>[/codesyntax] start_recording(output, format=None, resize=None, **options) start_recording的参数只是一个字符串的话，会被当作是文件名；如果是个对象的话，会回调这个实例对象的write方法 录制的文件格式默认为h264。wait_recording函数规定了录制的时长。 要想关闭红灯显示的话，可以设置camera.led = False。</p>
<p><strong>以上就是对人脸识别的小小见解。</strong></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[web网站从linux移植到windows server 2008]]></title>
      <url>/5.html/</url>
      <content type="html"><![CDATA[<p>其实对于web服务器配置并没有多难，但是比较繁琐，很多问题需要经验，所有记之。<br><a id="more"></a><br>最终项目还是从空间到centos选择了windows 的怀抱，原因很简单，蛋疼的空间不是尔等凡夫俗子所能够征服的。linux也不是一天能够玩转的。<br>对于网站的移植无非做几件事:</p>
<ul>
<li>搭建windows server 2008服务器PHP运行环境</li>
<li>备份linux下的web程序源码和数据库数据</li>
<li>导入web程序源码和数据库配置</li>
<li>设置域名解析</li>
</ul>
<h4 id="搭建windows-server-2008服务器PHP运行环境"><a href="#搭建windows-server-2008服务器PHP运行环境" class="headerlink" title="搭建windows server 2008服务器PHP运行环境"></a>搭建windows server 2008服务器PHP运行环境</h4><p>Windows下面的IIS加phpStudy就是简单，呵呵。<br><a href="http://www.jb51.net/article/49865.htm" target="_blank" rel="external">借鉴</a><br>当然对于上面的网址我有以下几点补充:</p>
<ul>
<li>IIS配置时”应用程序开发”最好全选</li>
<li>更改IIS的默认文档设置</li>
<li>添加web程序文件夹权限为<code>everyone</code>，所有权限</li>
<li>phpStudy设置为管理员权限启动<br>在IIS里面添加网站内容，挺简单的操作。<h4 id="备份linux下的web程序源码和数据库数据"><a href="#备份linux下的web程序源码和数据库数据" class="headerlink" title="备份linux下的web程序源码和数据库数据"></a>备份linux下的web程序源码和数据库数据</h4><h5 id="备份linux下的web程序源码"><a href="#备份linux下的web程序源码" class="headerlink" title="备份linux下的web程序源码"></a>备份linux下的web程序源码</h5>备份web程序源码，首先使用<code>Xshell</code>远程连接工具连接远程服务器，然后压缩web网站程序，但是竟然告诉我不能运行zip压缩命令。<br>没办法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install zip unzip</div></pre></td></tr></table></figure>
</li>
</ul>
<p>然后成功安装zip命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">zip  -r kjl.zip  kjl</div></pre></td></tr></table></figure></p>
<p>然后就可以压缩web程序了。</p>
<p>对于web程序的下载我没有用linux命令，我使用了我喜欢的<code>FileZilla</code>服务器连接工具，嘿嘿，反正我觉得这个工具比较强大。<br>下载web程序的压缩包到本地。</p>
<h5 id="备份数据库数据"><a href="#备份数据库数据" class="headerlink" title="备份数据库数据"></a>备份数据库数据</h5><p>对于空间数据库的坑爹我已不想多说，幸好得到了<code>Navicat for MySQL</code>程序的眷恋，远程连接数据库备份数据库没问题而言。<br>登录后选中数据库，右键<code>转储SQL</code>即可，这样数据库备份就没有任何问题而言了。</p>
<h4 id="导入web程序源码和数据库配置"><a href="#导入web程序源码和数据库配置" class="headerlink" title="导入web程序源码和数据库配置"></a>导入web程序源码和数据库配置</h4><p>对于windows服务器，当然还是windows内部的<code>远程桌面连接</code>给力，通过与远程共享文件夹与本地进行数据的传输。<br>将web程序源码放到www网站目录里面即可。sql文件通过phpStudy里面的<code>MySQL-Front</code>先建立数据库，然后导入即可。需要注意的是文件所有编码必须保持一致吧！小编一致使用<code>utf8</code>。</p>
<h4 id="设置域名解析"><a href="#设置域名解析" class="headerlink" title="设置域名解析"></a>设置域名解析</h4><p>对于域名解析，当初二话不说上阿里云进行域名解析，谁知道它的域名来着<code>网易中国</code>，没办法，直接上网易中国进行域名解析。域名解析之前可能觉得高大上，但是解析多了才发现操作并没有想象中的那么简单。</p>
<h4 id="小小教训"><a href="#小小教训" class="headerlink" title="小小教训"></a>小小教训</h4><p>说实话，我真的不能够明白的是基于thinkcmf的二次开发网站时，所有东西布置完毕。但是为何就是不能显示正确呢？反而显示<code>404</code>，虽然表示无奈，但是打开<code>thinkphp</code>的调试模式,网站立即访问正确。<br>然后关闭调试模式，网站正确显示。</p>
<p><strong>以上就是我将web网站从linux移植到windows server 2008的整个过程了。</strong></p>
]]></content>
      
        <categories>
            
            <category> PHP </category>
            
        </categories>
        
        
        <tags>
            
            <tag> php </tag>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mysql常用命令简介]]></title>
      <url>/4.html/</url>
      <content type="html"><![CDATA[<p>mysql是一个关系型数据库管理系统，由于其开源免费，在web开发方面占有重要地位。<br><a id="more"></a><br>今天我们所说的是mysql的命令行模式，不同于常规的视图操作界面。</p>
<h4 id="mysql服务相关"><a href="#mysql服务相关" class="headerlink" title="mysql服务相关"></a>mysql服务相关</h4><p>　　我们可以这样理解，mysql的正常运行离不开mysql服务的正常启动。所有对于这些我们必须掌握。</p>
<ul>
<li>启动mysql服务<br>可以使用命令:<ul>
<li>mysql脚本启动: <code>/etc/init.d/mysqld start</code></li>
<li>service服务启动:<code>service mysqld start</code></li>
<li>使用safe_mysqld启动:<code>safe_mysqld&amp;</code></li>
</ul>
</li>
<li>停止服务<ul>
<li>使用service停止:<code>service mysqld stop</code></li>
<li>使用mysqld脚本停止:<code>/etc/init.d/mysqld stop</code></li>
</ul>
</li>
<li>重启<ul>
<li>使用service重启:<code>service mysqld restart</code></li>
<li>使用mysqld脚本重启:<code>/etc/init.d/mysqld restart</code><br>备注:查看mysql端口是否已经使用，使用netstat -anp命令查询服务器端口使用情况。</li>
</ul>
</li>
</ul>
<h4 id="进入mysql"><a href="#进入mysql" class="headerlink" title="进入mysql"></a>进入mysql</h4><ul>
<li><p>连接本地(在安装目录下操作)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /mysql/bin#与具体安全目录有关</div><div class="line">mysql -u root -p #回车后输入密码</div><div class="line">mysql&gt; #成功后显示</div></pre></td></tr></table></figure>
</li>
<li><p>连接远程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -h 110.110.110.110 -u root -p 123;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注:其实各参数与数据可以不用加空格。</p>
<h4 id="退出mysql"><a href="#退出mysql" class="headerlink" title="退出mysql"></a>退出mysql</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">exit(回车)</div></pre></td></tr></table></figure>
<h4 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h4><ul>
<li>给root加个密码abcd1234<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysqladmin -u root -password abcd1234</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注:之前root没有密码，所有-p旧密码可以省略。</p>
<ul>
<li>修改root密码为1234abcd<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysqladmin -u root -p abcd1234 password 1234abcd</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="新增用户"><a href="#新增用户" class="headerlink" title="新增用户"></a>新增用户</h4><p>格式：grant select on 数据库.* to 用户名@登录主机 identified by “密码”<br>注：个人觉得有些繁琐，且大部分时间不会新增，特此google即可。</p>
<h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><p>命令:<code>create database &lt;数据库名&gt;</code></p>
<h4 id="显示数据库"><a href="#显示数据库" class="headerlink" title="显示数据库"></a>显示数据库</h4><p>命令：<code>show databases;</code></p>
<h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h4><p>命令:<code>drop database &lt;数据库名&gt;；</code></p>
<h4 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h4><p>命令:<code>use &lt;数据库名&gt;；<code></code></code></p>
<h4 id="显示数据表"><a href="#显示数据表" class="headerlink" title="显示数据表"></a>显示数据表</h4><p>命令:<code>show tables;</code></p>
<h4 id="增加数据记录"><a href="#增加数据记录" class="headerlink" title="增加数据记录"></a>增加数据记录</h4><p> 命令:<code>insert into &lt;表名&gt;(字段名1,字段名2,…,字段名n) values(值1,值2,…,值n);</code></p>
<h4 id="删除数据记录"><a href="#删除数据记录" class="headerlink" title="删除数据记录"></a>删除数据记录</h4><p> 命令:<code>delete from 表名 where 表达式;</code></p>
<h4 id="修改数据记录"><a href="#修改数据记录" class="headerlink" title="修改数据记录"></a>修改数据记录</h4><p> 命令:<code>update from 表名 set 字段 = ‘新值’ where 表达式;</code></p>
<h4 id="查询数据记录"><a href="#查询数据记录" class="headerlink" title="查询数据记录"></a>查询数据记录</h4><p> 命令:<code>select * from 表名 (where 表达式) ;</code></p>
<p> 注：对于字段、索引和实例等其他复杂操作在此就不一一介绍了，以上就是在liunx操作mysql常用的命令了。</p>
<p><a href="http://www.cnblogs.com/zhangzhu/archive/2013/07/04/3172486.html" target="_blank" rel="external">其他操作可借鉴</a>  </p>
]]></content>
      
        <categories>
            
            <category> PHP </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql </tag>
            
            <tag> php </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vim的简单使用]]></title>
      <url>/3.html/</url>
      <content type="html"><![CDATA[<p>vim是一个类似于vi的著名的功能强大、高度可定制的文本编辑器，在vi的基础上改进和增加了很多特性。vim是自由软件。<br><a id="more"></a><br>其实vim有着很强悍的操作语法，但是在这我只是介绍一些常用能解决文章的基本操作，原因很简单：适合新手！</p>
<h4 id="vi的基本概念"><a href="#vi的基本概念" class="headerlink" title="vi的基本概念"></a>vi的基本概念</h4><p>　　基本上vi可以分为三种状态，分别是命令模式、插入模式和底行模式，各模式的功能区分如下：</p>
<ul>
<li>命令行模式</li>
</ul>
<p>　　控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入插入模式下，<br>或者到底行模式。</p>
<ul>
<li><p>插入模式<br>　　只有在插入模式下，才可以做文字输入，按「ESC」键可回到命令行模式。</p>
</li>
<li><p>底行模式</p>
</li>
</ul>
<p>将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。<br>不过一般我们在使用时把vi简化成两个模式，就是将底行模式也算入命令行模式。</p>
<ul>
<li><p>进命令行模式<br>在进入插入模式后，你只要按[Esc]就可以从插入模式进入命令行模型了。</p>
</li>
<li><p>进入插入模式<br>刚开始打开vim，你必须按i才能进入插入模式。</p>
</li>
<li><p>进入底行模式<br>在使用底行模式之前，请记住先按「ESC」键确定您已经处于命令行模式下后，再按「：」冒号即可进入底行模式。</p>
</li>
</ul>
<h4 id="vim的常规操作"><a href="#vim的常规操作" class="headerlink" title="vim的常规操作"></a>vim的常规操作</h4><ul>
<li>列出行号</li>
</ul>
<p>　「set nu」：输入「set nu」后，会在文件中的每一行前面列出行号。</p>
<ul>
<li>跳到文件中的某一行</li>
</ul>
<p>　「#」：「#」号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，<br>如输入数字15，再回车，就会跳到文章的第15行。</p>
<ul>
<li>查找字符</li>
</ul>
<p>　「/关键字」：先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想<br>要的，可以一直按「n」会往后寻找到您要的关键字为止。</p>
<p>　「?关键字」：先按「?」键，再输入您想寻找的字符，如果第一次找的关键字不是您想<br>要的，可以一直按「n」会往前寻找到您要的关键字为止。</p>
<ul>
<li>保存文件</li>
</ul>
<p>　「w」：在冒号输入字母「w」就可以将文件保存起来。</p>
<ul>
<li><p>保存并退出<br>　按ESC键 跳到命令模式，然后：<br>　:w   保存文件但不退出vi<br>　:w file 将修改另外保存到file中，不退出vi<br>　:w!   强制保存，不推出vi<br>　:wq  保存文件并退出vi（常用）<br>　:wq! 强制保存文件，并退出vi（常用）<br>　q:  不保存文件，退出vi<br>　:q! 不保存文件，强制退出vi<br>　:e! 放弃所有修改，从上次保存文件开始再编辑</p>
</li>
<li><p>离开vi</p>
</li>
</ul>
<p>　「q」：按「q」就是退出，如果无法离开vi，可以在「q」后跟一个「!」强制离开vi。</p>
<p>　「wq」：一般建议离开时，搭配「w」一起使用，这样在退出的时候还可以保存文件。</p>
]]></content>
      
        <categories>
            
            <category> Liunx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vim </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git的常规使用]]></title>
      <url>/2.html/</url>
      <content type="html"><![CDATA[<p>首先需要本地git与远程github相连接。采取SSH连接方式。<br>此次教程对于git的使用做一个常规使用的总结，更多高级使用并未涉及。<br><a id="more"></a></p>
<h3 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h3><h4 id="创建ssh-key"><a href="#创建ssh-key" class="headerlink" title="创建ssh key"></a>创建ssh key</h4><p>为了让github能够识别是我们自己上传文件，需要创建ssh key<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ssh-keygen -t rsa -C &quot;your_email@youreamil.com&quot;</div></pre></td></tr></table></figure></p>
<p>这里的your_email@youremail.com是你的邮箱地址，在输入后会询问你是否保存创建的ssh key，点回车就好，然后要求输入你要设置的密码，如果直接回车表示不设密码。然后会提示你ssh key已经创建好。</p>
<h4 id="将ssh写入github"><a href="#将ssh写入github" class="headerlink" title="将ssh写入github"></a>将ssh写入github</h4><p>在windows中生成的id_rsa.pub文件一般在C:\Users\windows用户名\.ssh目录下，打开隐藏文件即可看到。<br>复制出来，在github在点击头像，然后点击setting，在找到SSH and GPG keys，创建一个new ssh key，然后将刚刚复制的ssh key填入即可。</p>
<h4 id="验证是否连接成功"><a href="#验证是否连接成功" class="headerlink" title="验证是否连接成功"></a>验证是否连接成功</h4><p>在终端输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh -T git@github.com</div></pre></td></tr></table></figure></p>
<p>如果回车看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">You’ve successfully authenticated, but GitHub does not provide shell access 。</div></pre></td></tr></table></figure></p>
<p>表示已成功连上github。</p>
<h4 id="设置username和email"><a href="#设置username和email" class="headerlink" title="设置username和email"></a>设置username和email</h4><p>在把本项目上传到github之前还需要分别输入设置username和email，因为github每次commit都会记录他们。所以分别输入如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name &quot;your name&quot;</div><div class="line">$ git config --global user.email &quot;your_email@youremail.com&quot;</div></pre></td></tr></table></figure></p>
<h4 id="添加远程地址"><a href="#添加远程地址" class="headerlink" title="添加远程地址"></a>添加远程地址</h4><p>在与github连接成功后，如何才能让相应的项目上传到对应的仓库呢？这里就需要添加远程地址，从而让我们的本地项目顺利到达对应的仓库。</p>
<p>打开终端，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote add origin git@github.com:yourName/yourRepo.git</div></pre></td></tr></table></figure></p>
<h3 id="上传项目"><a href="#上传项目" class="headerlink" title="上传项目"></a>上传项目</h3><h4 id="进入项目，在终端运行"><a href="#进入项目，在终端运行" class="headerlink" title="进入项目，在终端运行"></a>进入项目，在终端运行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git status</div></pre></td></tr></table></figure>
<p>查看当前目录索引还没有被git管理的文件和被git管理而被修改但还没有提交(git commit)的文件。</p>
<h4 id="将远程库与本地库合并"><a href="#将远程库与本地库合并" class="headerlink" title="将远程库与本地库合并"></a>将远程库与本地库合并</h4><p>(注:pull=fetch +merge )：(刚刚添加时本地没有说明文件)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git pull --rebase origin master</div></pre></td></tr></table></figure></p>
<h4 id="然后上传所有"><a href="#然后上传所有" class="headerlink" title="然后上传所有"></a>然后上传所有</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git add .</div></pre></td></tr></table></figure>
<h4 id="添加注释并上传到缓存区"><a href="#添加注释并上传到缓存区" class="headerlink" title="添加注释并上传到缓存区"></a>添加注释并上传到缓存区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m  &apos;本次提交注释&apos;</div></pre></td></tr></table></figure>
<p>提交并上传代码，第一次提交加上’-u’,后面提交可以省略。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push -u origin master</div></pre></td></tr></table></figure></p>
<h3 id="以后提交"><a href="#以后提交" class="headerlink" title="以后提交"></a>以后提交</h3><ul>
<li><p>上传所有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git add .</div></pre></td></tr></table></figure>
</li>
<li><p>添加注释并上传到缓存区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m  &apos;本次提交注释&apos;</div></pre></td></tr></table></figure>
</li>
<li><p>提交并上传代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin master</div></pre></td></tr></table></figure>
</li>
</ul>
<p>如此往复即可。</p>
]]></content>
      
        <categories>
            
            <category> PHP </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[建立博客]]></title>
      <url>/1.html/</url>
      <content type="html"><![CDATA[<p>由于诸多原因，我最终选择了hexo+github搭建博客，原因嘛有很多。但是markdown的编写方式和纯命令的编辑方式是我所喜爱的。<br><a id="more"></a><br>我不知道在其他人眼里git意味着什么，但是不知不觉中我觉得我思想发生了一些改变。喜欢上了一些高大上的程序员方式。<br>之前打算用yii2.0搭建博客，但是markdown插件弄了好久都没有弄出来，然后按照yii2.0博客程序也存在弊端；node.js搭建博客弄了弄，使用了Ghost博客程序也不太喜欢，发现英文大多不太喜欢，而且服务器的配置太繁琐，不想hexo几行命令即可搞定。<br>不过我从头到尾都没有想过使用WordPress，原因很简单，没有轻量级的书写方式，不够简洁，我觉得博客的本质应该是写作。<br>专注于写作和学习，这才是我建立博客的主旨。</p>
]]></content>
      
        
    </entry>
    
  
  
</search>
