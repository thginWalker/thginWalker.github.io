<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[论考研内心的躁动]]></title>
      <url>/%E8%AE%BA%E8%80%83%E7%A0%94%E5%86%85%E5%BF%83%E7%9A%84%E8%BA%81%E5%8A%A8.html/</url>
      <content type="html"><![CDATA[<p>We already walked too far, down to we had forgotten why embarked.<br><code>我们已经走得太远，以至于忘记了为什么而出发。</code><br><a id="more"></a></p>
<h2 id="小感"><a href="#小感" class="headerlink" title="小感"></a>小感</h2><p>今天早晨6:03分在宿舍的楼梯看见了我”大哥”,看的出来我”大哥”已经全身心投入考研的准备了。而此刻的我仍处于迷茫之中。<br>随后简单的吃完早饭，打破常规的能够早起前去图书馆。仍在看朱伟的《恋练有词》的导读部分，才感慨学习绝不是一蹴而就，它有的往往的日常平凡的坚守。<br>我深知处于实训的我的迷茫，绝不是他人所能理解的。有的时候才发现往往不是自己不够优秀，而是自己不够努力。</p>
<h2 id="关于考研"><a href="#关于考研" class="headerlink" title="关于考研"></a>关于考研</h2><p>虽说考研心思早已萌发，但却仍为起步。之前的自己认为一切皆有可能，后来才发现不得不想现实低头。其实从真正开始面对软考”网络工程师”时就早有体会了。<br>从工作室的学哥学姐考研的经历让我深刻意识到了考研并没有想象中的那么简单。当然，在有心人眼里也没有想象中的那么困难。无论如何，放手一搏，终能成功一帆事业。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>考研故有专硕与学硕之分，想必对于一个考研人来说往往万分纠结。当然笔者也不例外，只是思想发生了转变。之前的自己选择了专硕，往往认为只要能够考上研究生就可以了，但最终记住了这句话:<code>优秀的唯一方法是不降低对自己的要求。</code><br>为此我选择了学硕，只是希望自己能够对人生的学习能够画上一个圆满的结束。是的！我想考博，对于此刻还是一个普通的本科生竟然会有如何的想法。<br>我始终想去国外见证真正的世界吧，还是这句话说得不错:<code>世界很大，我想去看看。</code><br>之所以能够在这世界上来一遭，我想就不应该活得如何平庸吧！<br>今天的自己用自己的话激励自己:<code>我是很卑微，但我不想活得如此卑微。</code></p>
<h3 id="专业"><a href="#专业" class="headerlink" title="专业"></a>专业</h3><p>本身的专业是”软件工程”，考研专业仍在”软件工程”吧，即使此刻的自己对”网络安全”和”人工智能”痴迷。但我知道在技术的道路上我能够走得很遥远，不为其他，只为心中那份坚守。</p>
<h3 id="地区"><a href="#地区" class="headerlink" title="地区"></a>地区</h3><p>也许可能是家在安徽与湖北的交接处吧！况且湖北的省会”武汉”是一个现代化城市。<br>我觉得选择”武汉理工”是一个个冥冥之中的决定，况且学姐将是一个很好的引路人，我相信紧跟她的步伐我一定能够走得更远。</p>
<h2 id="写给自己"><a href="#写给自己" class="headerlink" title="写给自己"></a>写给自己</h2><p>也许很多时候做好自己就行，不要去考虑那些子虚乌有的事情。对于自身而言:</p>
<ul>
<li>目标要求远大</li>
<li>心胸要求广阔</li>
<li>学习要求刻苦</li>
<li>努力要求淡然</li>
</ul>
<p>不顾一切的去拼搏去追寻，至于结果本身早已是铁板钉钉的事实了。做好自己，用一颗平常心去寻找自己想要的一切。</p>
]]></content>
      
        <categories>
            
            <category> life </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 心情小记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[华为命令配置专题]]></title>
      <url>/%E5%8D%8E%E4%B8%BA%E5%91%BD%E4%BB%A4%E9%85%8D%E7%BD%AE%E4%B8%93%E9%A2%98.html/</url>
      <content type="html"><![CDATA[<p>学习网络的同学都能明白，思科视乎一家独大，但是在发展的潮流中华为也紧跟不舍，所以对于我们学习华为命令的配置也变得重要了。<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>华为虽然对于交换机、路由器的配置和思科不大相同，但是我们能够理解的是不同的只是形式，其内部协议、原理也不过尔尔而已。<br>(针对此配置笔者了解甚少，多看书中实例理解)</p>
<h2 id="命令视图"><a href="#命令视图" class="headerlink" title="命令视图"></a>命令视图</h2><ol>
<li><p>用户视图(查看交换机简单运行状态和统计信息)</p>
<blockquote>
<p><quidway>:        与交换机建立连接即进入</quidway></p>
</blockquote>
</li>
<li><p>系统视图(配置系统参数)</p>
<blockquote>
<p>[Quidway]:       在用户视图下键入system-view</p>
</blockquote>
</li>
<li><p>以太网视图(配置以太网端口参数)</p>
<blockquote>
<p>[Quidway-Ethernet0/1]:       在系统视图下键入interface ethernet 0/1</p>
</blockquote>
</li>
</ol>
<ol>
<li><p>VLAN视图(配置VLAN参数)</p>
<blockquote>
<p>[Quidway-Vlan1]:       在系统视图下键入vlan 123</p>
</blockquote>
</li>
<li><p>VLAN接口视图(配置VLAN和VLAN汇聚对应的IP接口参数)</p>
<blockquote>
<p>[Quidway-Vlan1-interface]:       在系统视图下键入interface vlan-interface 123</p>
</blockquote>
</li>
<li><p>本地用户视图(配置本地用户参数)</p>
<blockquote>
<p>[Quidway-luser-user1]:       在系统视图下键入local-user-user1</p>
</blockquote>
</li>
<li><p>用户界面视图(配置用户界面参数)</p>
<blockquote>
<p>[Quidway-ui0]:       在系统视图下键入user-interface</p>
</blockquote>
</li>
</ol>
<h2 id="VLAN配置方法"><a href="#VLAN配置方法" class="headerlink" title="VLAN配置方法"></a>VLAN配置方法</h2><p>『配置环境参数』<br>SwitchA端口E0/1属于VLAN2、E0/2属于VLAN3<br>『组网需求』<br>把交换机端口E0/1就让到VLAN2、E0/2加入到VLAN3<br>数据配置步骤<br>『VLAN配置流程』</p>
<ol>
<li>缺省情况下所有端口都属于VLAN1，并且端口是access端口，一个access端口智能属于一个vlan;</li>
<li>如果端口是access端口，则把端口加入到另外一个vlan的同时，系统自动把该端口从原来的vlan中删除掉；</li>
<li>除了VLAN1，如果VLAN XX不存在，在系统视图下键入VLAN XX，则创建VLAN XX并进入VLAN XX视图；如果VLAN XX已经参照，则进入VLAN视图。</li>
</ol>
<p>解析<br>【SwitchA相关配置】</p>
<ul>
<li><p>方法一:</p>
<ol>
<li><p>创建(进入)vlan 2</p>
<blockquote>
<p> [SwitchA]vlan 2</p>
</blockquote>
</li>
<li><p>将端口E0/1加入到vlan 2</p>
<blockquote>
<p> [SwitchA-vlan2]port ethernet 0/1</p>
</blockquote>
</li>
<li><p>创建(进入)vlan 3</p>
<blockquote>
<p>[SwitchA-vlan2]vlan 3</p>
</blockquote>
</li>
<li><p>将端口E0/2加入到vlan3</p>
<blockquote>
<p>[SwitchA-vlan3]port ethernet 0/2</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>方法二</p>
<ol>
<li><p>创建(进入)vlan 2</p>
<blockquote>
<p> [SwitchA]vlan 2</p>
</blockquote>
</li>
<li><p>进入端口E0/1视图</p>
<blockquote>
<p> [SwitchA]interface ethernet 0/1</p>
</blockquote>
</li>
<li><p>指定端口E0/1属于vlan2</p>
<blockquote>
<p>[SwitchA-ethernet]port access vlan 2</p>
</blockquote>
</li>
<li><p>创建(进入)vlan 3</p>
<blockquote>
<p> [SwitchA]vlan 3</p>
</blockquote>
</li>
<li><p>进入端口E0/1视图</p>
<blockquote>
<p> [SwitchA]interface ethernet 0/2</p>
</blockquote>
</li>
<li><p>指定端口E0/1属于vlan3</p>
<blockquote>
<p>[SwitchA-ethernet]port access vlan 3</p>
</blockquote>
</li>
</ol>
<p>测试验证</p>
</li>
<li><p>使用命令<code>disp cur</code>可以看到端口E0/1属于vlan2、E0/2属于vlan3；</p>
</li>
<li>使用<code>display interface Ethernet 0/1</code>可以看到端口为access端口、PVID为2；</li>
<li>使用<code>display interface Ethernet 0/2</code>可以看到端口为access端口、PVID为3</li>
</ul>
<h2 id="交换机IP地址配置"><a href="#交换机IP地址配置" class="headerlink" title="交换机IP地址配置"></a>交换机IP地址配置</h2><p>功能需求及组网说明<br>『配置环境参数』<br>三层交换机SwitchA有两个端口ethernet0/1、ethernet0/2，分别属于vlan 2、vlan 3；<br>以vlan 2的三层接口地址分别是1.0.0.1/24作为PC1的网关；<br>以vlan 3的三层接口地址分别是2.0.0.1/24作为PC1的网关；<br>『组网需求』(此部分为本实验重点联系内容)<br>PC1和PC2通过三层接口互通</p>
<p>解析<br>『SwitchA相关配置』</p>
<ol>
<li><p>创建(进入)vlan2</p>
<blockquote>
<p>[Quidway]vlan 2</p>
</blockquote>
</li>
<li><p>将端口E0/1加入到vlan2</p>
<blockquote>
<p>[Quidway-vlan2]port ethernet 0/1</p>
</blockquote>
</li>
<li><p>进入vlan2的虚接口</p>
<blockquote>
<p>[Quidway-vlan2]interface vlan 2</p>
</blockquote>
</li>
<li><p>在vlan2的虚接口上配置</p>
<blockquote>
<p>[Quidway-Vlan-interface2]ip address 1.0.0.1 255.255.255.0</p>
</blockquote>
</li>
<li><p>创建(进入)vlan3</p>
<blockquote>
<p>[Quidway]vlan 3</p>
</blockquote>
</li>
<li><p>将E0/2加入到vlan3</p>
<blockquote>
<p>[QUidway-Vlan3]port ethernet 0/2</p>
</blockquote>
</li>
<li><p>进入vlan3的虚接口</p>
<blockquote>
<p>[QUidway-Vlan3]interface vlan 3</p>
</blockquote>
</li>
<li><p>在vlan3的虚接口上配置IP地址</p>
<blockquote>
<p>[QUidway-Vlan-interface3]ip address 2.0.0.1 255.255.255.0</p>
</blockquote>
</li>
</ol>
<p>测试验证</p>
<ul>
<li>PC1和PC2都可以ping同自己的网关</li>
<li>PC1和PC2都可以相互ping通</li>
</ul>
<h2 id="端口trunk配置"><a href="#端口trunk配置" class="headerlink" title="端口trunk配置"></a>端口trunk配置</h2><p>内容<br>『配置环境参数』</p>
<ul>
<li>SwitchA端口E0/1属于vlan10，E0/2属于van20，E0/3与SwitchB端口E0/3互连</li>
<li>SwitchB端口E0/1属于vlan10，E0/2属于van20，E0/3与SwitchA端口E0/3互连<br>『组网需求』</li>
<li>要求SwitchA的vlan10的PC与SwitchB的vlan10的PC互通</li>
<li>要求SwitchA的vlan20的PC与SwitchB的vlan20的PC互通</li>
</ul>
<p>解析<br>数据配置步骤<br>『SwitchA相关配置』</p>
<ol>
<li><p>创建(进入)vlan10</p>
<blockquote>
<p>[SwitchA]vlan 10</p>
</blockquote>
</li>
<li><p>将E0/1加入到vlan10</p>
<blockquote>
<p>[SwitchA-vlan10]port Ethernet 0/1</p>
</blockquote>
</li>
<li><p>创建(进入)vlan20</p>
<blockquote>
<p>[SwitchA]vlan 20</p>
</blockquote>
</li>
<li><p>将E0/2加入到vlan20</p>
<blockquote>
<p>[SwitchA-vlan20]port Ethernet 0/2</p>
</blockquote>
</li>
<li><p>实际当中一般将上行端口设置成trunk属性，允许vlan透传</p>
<blockquote>
<p>[SwitchA-Ethernet0/3]port link-type trunk</p>
</blockquote>
</li>
<li><p>允许所有的vlan从E0/3端口透传通过，也可以指定具体的vlan值</p>
<blockquote>
<p>[SwitchA-Ethernet0/3]port trunk permit vlan all</p>
</blockquote>
</li>
</ol>
<p>『SwitchB相关配置』</p>
<ol>
<li><p>创建(进入)vlan10</p>
<blockquote>
<p>[SwitchB]vlan 10</p>
</blockquote>
</li>
<li><p>将E0/1加入到vlan10</p>
<blockquote>
<p>[SwitchB-vlan10]port Ethernet 0/1</p>
</blockquote>
</li>
<li><p>创建(进入)vlan20</p>
<blockquote>
<p>[SwitchB]vlan 20</p>
</blockquote>
</li>
<li><p>将E0/2加入到vlan20</p>
<blockquote>
<p>[SwitchB-vlan20]port Ethernet 0/2</p>
</blockquote>
</li>
<li><p>实际当中一般将上行端口设置成trunk属性，允许vlan透传</p>
<blockquote>
<p>[SwitchB-Ethernet0/3]port link-type trunk</p>
</blockquote>
</li>
<li><p>允许所有的vlan从E0/3端口透传通过，也可以指定具体的vlan值</p>
<blockquote>
<p>[SwitchB-Ethernet0/3]port trunk permit vlan all</p>
</blockquote>
</li>
</ol>
<p>【补充说明】</p>
<ul>
<li>如果一个端口是trunk端口，则该端口可以属于多个vlan；</li>
<li>缺省情况下trunk端口的PVID为1，可以在端口模式下通过命令port trunk vlan vlanid 来修改端口的PVID；</li>
<li>如果从trunk转发出去的数据报文的vlan id和端口的PVID一致，则该报文的VLAN会被剥去，这点在配置trunk端口时需要注意；</li>
<li>一台交换机上如果已经设置了某个端口为hybrid端口，则不可以再把另外的端口设置为trunk端口；</li>
<li>一般情况下最好指定端口允许通过哪些具体的VLAN，不要设置允许所有的VLAN通过。</li>
</ul>
<p>测试验证</p>
<ol>
<li>SwitchA vlan10内的PC可以与SwitchB vlan10内的PC互通</li>
<li>SwitchA vlan20内的PC可以与SwitchB vlan20内的PC互通</li>
<li>SwitchA vlan10内的PC不能与SwitchB vlan20内的PC互通</li>
<li>SwitchA vlan20内的PC不能与SwitchB vlan10内的PC互通</li>
</ol>
<h2 id="端口汇聚配置"><a href="#端口汇聚配置" class="headerlink" title="端口汇聚配置"></a>端口汇聚配置</h2><p> 内容<br>『配置环境参数』</p>
<ol>
<li>交换机SwitchA和SwitchB通过以太网口实现互连。</li>
<li>SwitchA用于互连的端口为e0/1和e0/2，SwitchB用于互连的端口为e0/1和e/2。</li>
</ol>
<p>『组网需求』<br>增加SwitchA的SwitchB的互连链路的带宽，并且能够实现链路备份，使用端口汇聚 数据配置步骤<br>解析<br>【SwitchA交换机配置】</p>
<ol>
<li><p>进入端口E0/1</p>
<blockquote>
<p>[SwitchA]interface Ethernet 0/1</p>
</blockquote>
</li>
<li><p>汇聚端口必须关注在全双工模式</p>
<blockquote>
<p>[SwitchA-Ethernet0/1]duplex full</p>
</blockquote>
</li>
<li><p>汇聚的端口速率要求相同，但不能是自适应</p>
<blockquote>
<p>[SwitchA-Ethernet0/2]speed 100</p>
</blockquote>
</li>
<li><p>进入端口E0/2</p>
<blockquote>
<p>[SwitchA]interface Ethernet 0/2</p>
</blockquote>
</li>
<li><p>汇聚端口必须关注在全双工模式</p>
<blockquote>
<p>[SwitchA-Ethernet0/2]duplex full</p>
</blockquote>
</li>
<li><p>汇聚的端口速率要求相同，但不能是自适应</p>
<blockquote>
<p>[SwitchA-Ethernet0/2]speed 100</p>
</blockquote>
</li>
<li><p>根据源和目的MAC进行端口选择汇聚</p>
<blockquote>
<p>[SwitchA]link-aggergation Ethernet 0/1 to Ethernet 0/2 both</p>
</blockquote>
</li>
</ol>
<p>【SwitchB交换机配置】</p>
<blockquote>
<p>[SwitchB]interface Ethernet 0/1<br>[SwitchB-Ethernet0/1]duplex full<br>[SwitchB-Ethernet0/2]speed 100<br>[SwitchB]interface Ethernet 0/2<br>[SwitchB-Ethernet0/2]duplex full<br>[SwitchB-Ethernet0/2]speed 100<br>[SwitchB]link-aggergation Ethernet 0/1 to Ethernet 0/2 both</p>
</blockquote>
<p>【补充说明】</p>
<ul>
<li>同一个汇聚组中成员端口的链接类型与注端口的链路类型保存一致，即如果主端口为Trunk端口，则成员端口也为Trunk端口；<br>如主端口的链路类型改为Access端口，则成员端口的链路类型也变为Access端口。</li>
<li>不同的产品对端口汇聚是的起始端口号要去各有不同，请对照《操作手册》进行配置。</li>
</ul>
<h2 id="端口镜像配置"><a href="#端口镜像配置" class="headerlink" title="端口镜像配置"></a>端口镜像配置</h2><p>内容<br>『环境配置参数』</p>
<ol>
<li>PC1接在交换机E0/1端口，IP地址1.1.1.1/24</li>
<li>PC2接在交换机E0/2端口，IP地址2.2.2.2/24</li>
<li>E0/24为交换机上行端口</li>
<li>Server接在交换机E0/8端口，盖端口作为镜像端口</li>
</ol>
<p>『组网需求』</p>
<ol>
<li>通过交换机端口镜像的功能使用server对两台pc的业务报文进行监控。<br>根据Qidway交换机不同型号，镜像有不同方式进行配置:基于端口的进行 基于断句的镜像十八辈镜像端口的进出数据报文完全拷贝一份到镜像端口，这样来进行流量观测或者故障定位。</li>
</ol>
<p>基于流的镜像 基于流镜像的交换机针对某些流进行镜像，每个连接都有两个方向的数据流，对于交换机来说这两个数据流是要分开镜像的。</p>
<p>S2008/S2016/S2026/S2403H/S3026等交换机支持的都是基于端口的镜像<br>8016交换机支持基于端口的镜像<br>3500/3026E/3026F/2050支持基于流的镜像<br>5516/6505/6503/6506R支持对入端口流量进行镜像</p>
<p>解析<br>数据配置步骤<br>以Quidway S3026C为例，通过基于二层流的镜像进行配置：</p>
<ol>
<li><p>定义一个ACL</p>
<blockquote>
<p>[SwitchA]acl num 200</p>
</blockquote>
</li>
<li><p>定义一个规则从E0/1发送至其它所有端口的数据包</p>
<blockquote>
<p>[SwitchA]rule 0 permir ingress interface Ethernet0/1 egress interface Ethernet 0/2</p>
</blockquote>
</li>
<li><p>定义一个规则从其它所有端口到E0/1端口的数据包</p>
<blockquote>
<p>[SwitchA]rule 1 permir ingress interface Ethernet0/2 egress interface Ethernet 0/1</p>
</blockquote>
</li>
</ol>
<ol>
<li>将符合上述ACL的数据包镜像到E0/8<blockquote>
<p>[SwitchA]mirrored-to link-group 200 interface e0/8</p>
</blockquote>
</li>
</ol>
<h2 id="生成树STP配置"><a href="#生成树STP配置" class="headerlink" title="生成树STP配置"></a>生成树STP配置</h2><p>内容<br>『配置环境参数』</p>
<ol>
<li>交换机SwitchA、SwitchB和SwitchC都通过GE接口互连</li>
<li>SwitchB和SwitchC交换机是核心交换机，要求主备</li>
</ol>
<p>『组网要求』要求整个网络运行STP协议 数据配置步骤</p>
<p>解析</p>
<ol>
<li><p>【SwitchA交换机配置】启动生成树协议：</p>
<blockquote>
<p>[SwitchA]stp enable</p>
</blockquote>
</li>
<li><p>【SwitchB交换机配置】启动生成树协议：</p>
<blockquote>
<p>[SwitchB]stp enable</p>
</blockquote>
</li>
<li><p>配置本桥为根桥</p>
<blockquote>
<p>[SwitchB] stp root primary</p>
</blockquote>
</li>
<li><p>【SwitchC交换机配置】<br>a 启动生成树协议</p>
<blockquote>
<p>[SwitchC]stp enable</p>
</blockquote>
</li>
</ol>
<p>b 配置本桥为备份根桥</p>
<blockquote>
<p>[SwitchC]stp root secondary</p>
</blockquote>
<p>  5.【SwitchD交换机配置】<br>  a 启动生成树协议</p>
<blockquote>
<p>[SwitchD]stp enable</p>
</blockquote>
<p>【补充说明】</p>
<ol>
<li>缺省情况下交换机的优先级都是32768，如果想人为指定某一台交换机为根交换机，也可以通过修改优先级来实现；</li>
<li>缺省情况下打开生成树后，所有端口都会开启生成树解析，请把接PC的端口改为边缘端口模式；</li>
<li>如果要控制某条链路的状态可以通过设置端口的cost值来实现</li>
</ol>
<p>测试验证</p>
<ol>
<li>使用display stp查看交换机STP运行状态</li>
<li>查看端口STP状态display stp interface Ethernet XX是否正确</li>
</ol>
<h2 id="Quidway交换机维护"><a href="#Quidway交换机维护" class="headerlink" title="Quidway交换机维护"></a>Quidway交换机维护</h2><p>内容<br>显示系统版本信息: <code>display version</code><br>显示诊断信息: <code>display diagnostic-information</code><br>显示系统当前配置: <code>display current-configuration</code><br>显示系统保存配置: <code>display saved-configuration</code><br>显示接口信息: <code>display interface</code><br>显示路由信息: <code>display ip routing-table</code><br>显示VLAN信息: <code>display vlan</code><br>显示生成树信息: <code>display stp</code><br>显示MAC地址表: <code>display mac-address</code><br>显示ARP表信息: <code>display arp</code><br>显示系统CPU使用率: <code>display memory</code><br>显示系统日志: <code>display log</code><br>显示系统时钟: <code>display clock</code><br>删除某条命令，一般使用命令<code>undo</code></p>
<p>解析</p>
<ul>
<li><p>【SwitchA交换机配置】启动生成树协议:</p>
<blockquote>
<p>[SwitchA]stp enable</p>
</blockquote>
</li>
<li><p>【SwitchB交换机配置】启动生成树协议:</p>
<blockquote>
<p>[SwitchB]stp enable</p>
</blockquote>
</li>
<li><p>配置本桥为根桥</p>
<blockquote>
<p>[SwitchB]stp root primary</p>
</blockquote>
</li>
<li><p>【SwitchC交换机配置】<br> a. 启动生成树协议:</p>
<blockquote>
<p>[SwitchC]stp enable</p>
</blockquote>
</li>
</ul>
<pre><code>b. 配置本桥为备份根桥
</code></pre><blockquote>
<p>[SwitchC]stp root secondary</p>
</blockquote>
<ul>
<li>【SwitchD交换机配置】<br> a. 启动生成树协议:<blockquote>
<p>[SwitchD]stp enable</p>
</blockquote>
</li>
</ul>
<p>【补充说明】</p>
<ul>
<li>缺省情况下交换机的优先级都是32768，如果想认为指定某一台交换机为根交换机，也可以通过修改优先级来实现；</li>
<li>缺省情况下打开生成树后，所有端口都会开启生成树协议，请把接PC的端口改为边缘端口模式；</li>
<li>如果要控制某条链路的状态可以通过设置的cost值来实现。</li>
</ul>
<p>测试验证</p>
<ol>
<li>使用display stp查看交换机STP运行状态</li>
<li>查看端口STP状态display stp interface Ethernet XX是否正确</li>
</ol>
<p><strong>以上就是对华为命令配置专题的小小见解。</strong></p>
]]></content>
      
        <categories>
            
            <category> 网络攻防 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IPv6配置与部署]]></title>
      <url>/IPv6%E9%85%8D%E7%BD%AE%E4%B8%8E%E9%83%A8%E7%BD%B2.html/</url>
      <content type="html"><![CDATA[<p>由于从IPv4向IPv6过渡是大势所趋，因此就目前学习IPv6来说可谓明智之举。<br><a id="more"></a><br>就目前而言从IPv4向IPv6过渡的技术，主要分为<code>双栈</code>、<code>隧道</code>和<code>翻译</code>三种。</p>
<h2 id="IPv6-over-IPv4-GRE隧道配置"><a href="#IPv6-over-IPv4-GRE隧道配置" class="headerlink" title="IPv6-over-IPv4 GRE隧道配置"></a>IPv6-over-IPv4 GRE隧道配置</h2><p>IPv6-over-IPv4 GRE隧道是将IPv6报文封装在IPv4报文中，让IPv6数据包穿过IPv4网络进行通信。对于采用隧道技术的设备涞水，在隧道的入口出，将IPv6的数据报封装进IPv4,IPv4报文的源地址和目前地址分贝是隧道入库和隧道出口IPv4地址。<br>GRE隧道的相关配置命令<br>|命令|功能|<br>|::|::|<br>| interface 隧道接口号 | 启用隧道<em>隧道接口号</em> |<br>| ipv6 address ipv6地址/前缀长度 | 为tunnel配置IPv6地址|<br>| tunnel source ipv4地址 | 指定tunnel的源地址(也可是端口号) |<br>| tunnel destination ipv4地址 | 指定tunnel的目的地址 |<br>| tunnel mode gre ipv6 | tunnel模式为IPv6的GRE隧道|<br>配置隧道:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">R1(config)#interface tunnel 0</div><div class="line">R1(config-if)#tunnel source s1/0</div><div class="line">R1(config-if)#tunnel destination 202.100.2.2</div><div class="line">R1(config-if)#ipv6 address 2005:AAAA::1/64</div><div class="line">R1(config-if)#tunnel mode gre ipv6</div></pre></td></tr></table></figure></p>
<h2 id="ISATAP隧道配置"><a href="#ISATAP隧道配置" class="headerlink" title="ISATAP隧道配置"></a>ISATAP隧道配置</h2><p>站内自动隧道寻找寻址协议(ISATAP)过渡技术采用了双栈和隧道技术实现从IPv4向IPv6的过渡。<br>采用IASATAP地址，格式为Prefix(64bit):0:5EFE:IPv4地址，其中0:5EFE是IANA规定的格式。<br>ISATAP隧道协议使用于IPv4网络中IPv6主机的通信或IPv4网络中IPv4主机接入到IPv6网络的通信。<br>|命令|功能|<br>|::|::|<br>| tunnel mode ipv6 ip isatap | tunnel模式为IPv6的ISATAP隧道|<br>| no ipv6 nd suppress-ra | 启动隧道口的路由器广播 |<br>配置代码略</p>
<h2 id="NAT—PT"><a href="#NAT—PT" class="headerlink" title="NAT—PT"></a>NAT—PT</h2><p>网络地址转换协议转换(NAT-PT)是一种纯IPv6节点和IPv4节点的互通方式，所有包括地址、协议在内的转换工作都有网络设备来完成。</p>
<h3 id="静态NAT-PT"><a href="#静态NAT-PT" class="headerlink" title="静态NAT-PT"></a>静态NAT-PT</h3><p>(静态一对一)<br>|命令|功能|<br>|::|::|<br>| ipv6 nat | 启用NAT-PT机制 |<br>| ipv6 nat prefix ipv6地址/前缀长度 | 说明NAT-PT使用的IPv6前缀|<br>| ipv6 nat v6v4 source ipv6地址 | 强制将IPv6地址的输出IPv6数据包转换成IPv4数据包 |<br>| ipv6 nat v4v6 source ipv4地址 | 强制将IPv4地址的输出IPv4数据包转换成IPv6数据包 |</p>
<h3 id="动态NAT-PT"><a href="#动态NAT-PT" class="headerlink" title="动态NAT-PT"></a>动态NAT-PT</h3><p>(动态一对一)需要一个IPv4地址池。<br>|命令|功能|<br>|::|::|<br>| ipv6 <strong>access-list</strong> name <strong>permit</strong> ipv6地址/前缀|     定义运行被转换的ipv6地址范围 |<br>| ipv6 nat v6v4 <strong>pool</strong>ipv4-pool  开始ipv4地址 结束ipv4地址 prefix-length 前缀长度 | 规定转换过程中的源IPv4地址池 |<br>| ipv6 nat v6v4 source {list | route-map} {acl列表名 | 地图名 | 地址池名}  | 配置动态NAT-NT映射 |</p>
<h3 id="NAPT-PT"><a href="#NAPT-PT" class="headerlink" title="NAPT-PT"></a>NAPT-PT</h3><p>(动态多对一)<br>NAPT-PT配置与动态NAT-PT转换类似，只需要在映射时添加overload参数即可。<br>|命令|功能|<br>|::|::|<br>| ipv6 nat v6v4 source {list | route-map} {acl列表名 | 地图名 | 地址池名} overload  | 配置NAPT-NT映射 |<br><strong>以上就是我对IPv6配置与部署的小小见解。</strong></p>
]]></content>
      
        <categories>
            
            <category> 网络攻防 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IPSec的相关配置]]></title>
      <url>/IPSec%E7%9A%84%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE.html/</url>
      <content type="html"><![CDATA[<p>我们能够理解IPSec(IP   Security)是用于增强IP网络的安全性，因此请务必重视它。同时历年的考点也说明了这一点。<br><a id="more"></a></p>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><h3 id="为IPSec做准备"><a href="#为IPSec做准备" class="headerlink" title="为IPSec做准备"></a>为IPSec做准备</h3><p>确定策略，选择方法。</p>
<h3 id="配置IKE"><a href="#配置IKE" class="headerlink" title="配置IKE"></a>配置IKE</h3><ol>
<li>用isakmp enable命令启动或关闭IKE。</li>
<li>用isakmp policy命令创建IKE策略。</li>
<li>用isakmp key命令和相关配置预共享密钥。</li>
<li>用show isakmp [policy]命令验证IKE的配置</li>
</ol>
<h3 id="配置IPSec"><a href="#配置IPSec" class="headerlink" title="配置IPSec"></a>配置IPSec</h3><ol>
<li>用access-list命令配置加密用访问控制列表。</li>
<li>用crypto ipsec transform-set命令配置交换集。</li>
<li>(任选)用crypto ipsec security-association lifetime明亮配置全局性的IPSec安全关联的生存期。</li>
<li>用crypto map命令配置加密图。</li>
<li>用interface命令和crypto map-name interface把配置应用到接口上。</li>
<li>用各种可用的show命令验证IPSec的配置。</li>
</ol>
<h3 id="测试和验证IPSec"><a href="#测试和验证IPSec" class="headerlink" title="测试和验证IPSec"></a>测试和验证IPSec</h3><p>使用show、debug和相关的命令测试和验证IPSec加密是否正常。</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>总部端路由器部分配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">crypto isakmp policy 1</div><div class="line">authentication pre-share</div><div class="line">group 2</div><div class="line">crypto isakmp key test123 address 202.96.1.2</div><div class="line">crypto ipsec transform-set VPNtag ah-md5-hmac esp-des</div><div class="line">crypto map VPNdemo 10 ipsec-isakmp</div><div class="line">set peer 202.96.1.2</div><div class="line">set transform-set VPNtag</div><div class="line">match address 101</div><div class="line">interface Tunnel0</div><div class="line">ip address 68.1.1 255.255.255.0</div><div class="line">no ip directed-broadcast</div><div class="line">tunnel source 202.96.1.2</div><div class="line">crypto map VPNdemo</div><div class="line">ip route 0.0.0.0 0.0.0.0 202.96.1.2</div><div class="line">ip route 172.22.2.0 255.255.0.0 192.168.1.2</div><div class="line">access-list 101 permit gre host 202.96.1.1 host 202.96.1.2</div></pre></td></tr></table></figure></p>
<p>关注三对应：</p>
<ol>
<li>转换集名称5-8(VPNtag)</li>
<li>加密图名称6-15(VPNdemo)</li>
<li>ACL编号9-18(101)</li>
</ol>
<p><strong>以上就是对IPSec的小小见解。</strong></p>
]]></content>
      
        <categories>
            
            <category> 网络攻防 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[配置广域网接入]]></title>
      <url>/%E9%85%8D%E7%BD%AE%E5%B9%BF%E5%9F%9F%E7%BD%91%E6%8E%A5%E5%85%A5.html/</url>
      <content type="html"><![CDATA[<p>如果想访问其他远程网络，就必须是个广域网(WAN)接入服务了。<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>WAN与LAN使用的连接方式和布线标准不大相同。广域网中路由器和交换机的连接方式主要有<code>串行连接</code>、<code>ISDN BRI</code>和<code>DSL</code>连接的。<br>这里主要介绍软考所涉及的<code>ISDN</code>、<code>PPP</code>和<code>DDR</code>、<code>帧中继</code>等相关配置。<br>(针对此配置笔者了解甚少，多看书中实例理解)</p>
<h2 id="配置ISDN"><a href="#配置ISDN" class="headerlink" title="配置ISDN"></a>配置ISDN</h2><p>相关配置命令</p>
<p><table><br>    <tr><br>        <th>命令</th><br>        <th>功能</th><br>    </tr><br></table><br>| 命令 | 功能 |<br>|:—–:|:—-:|<br>| isdn switch-type 交换机类型 | 设置交换机类型 |<br>| interface bri 0 | 接口BRI设置 |<br>| encapsulation ppp | 设置PPP封装 |<br>| dialer map protocol 下一跳地址 [name 域名] [broadcast] [拨号串] | 设置协议地址与电话号码的映射 |<br>| ppp multilink   |  启动PPP多连接 |<br>| dialer load-threshold <em>load</em> | 设置启动另一个B通道的阀值 |<br>| show isdn {active | history | memory | services | status [dsl | interface-type number] | }|显示ISDN的有关信息 |</p>
<p>摘抄书中部分配置信息:<br>配置R1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">R1(config)#isdn switch-tyoe basic-net3</div><div class="line">R1(config)#interface bri 0</div><div class="line">R1(config-if)#ip address 192.168.1.1 255.255.255.0</div><div class="line">R1(config-if)#encapsulation ppp</div><div class="line">R1(config-if)#dialer string 80000002</div><div class="line">R1(config-if)#dialer-group 1</div><div class="line">R1(config-if)#no shutdown exit</div><div class="line">R1(config)#exit</div><div class="line">R1(config)#dialer-list l protocol ip permit</div><div class="line">R1(config)#end</div><div class="line">R1#</div></pre></td></tr></table></figure></p>
<h2 id="PPP和DDR"><a href="#PPP和DDR" class="headerlink" title="PPP和DDR"></a>PPP和DDR</h2><p>PPP(点对点协议)、DDR(按需拨号路由)，DDR技术和PPP技术一样对于ISDN的配置是非常重要的，在实际应用中ISDN、PPP和DDR这三项技术经常综合使用。<br>(针对此配置笔者了解甚少，多看书中实例理解)<br>相关配置命令<br>| 命令 | 功能 |<br>|:—–:|:—-:|<br>| encapsulation ppp | 设置PPP封装 |<br>| ppp authentication {chap | chap pap | pap chap | pap} [if-needed] [list-name | default] [callin]| 设置认证方法 |<br>| username <em>name</em> password secret | 指定口令|<br>| clockrate speed | 设置DCE段线路速度|<br>| ppp multilink | 启动PPP多连接 |<br>| dialer load-thresold load| 设置启动另一个B通道的阀值|<br>| show isdn {active | history | memory | services | status [dsl | interface-type number] | }|显示ISDN的有关信息 |<br>摘抄书中部分配置信息:<br>配置R1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">username R2 password 0 cisco</div><div class="line">isdn switch-type basic-net3</div><div class="line">!</div><div class="line">encapsulation ppp</div><div class="line">dialer idle-timeout 300</div><div class="line">dialer map ip 192.168.1.2 name R2 broadcast 80000002</div><div class="line">dialer load-threshold 128</div><div class="line">dialer-group 1</div><div class="line">no cdp enable</div><div class="line">ppp authentication chap </div><div class="line">ppp multilink</div><div class="line">！</div><div class="line">ip route 10.1.2.0 255.255.255.0 192.168.1.2</div><div class="line">!</div><div class="line">dialer-list 1 protocol ip permit</div><div class="line">...</div><div class="line">end</div></pre></td></tr></table></figure></p>
<h2 id="配置帧中继"><a href="#配置帧中继" class="headerlink" title="配置帧中继"></a>配置帧中继</h2><p>帧中继是一种高性能的WAN协议，运行在物理层和数据链路层，它是X.25的简化版本。<br>至于帧中继为何重要，从历年的软考真题就能明白一二了。<br>帧中继的相关配置命令<br>| 命令 | 功能 |<br>|:—–:|:—-:|<br>| encapsulation frame-relay [ietf] | 设置Frame Relay封装 |<br>| frame-relay lmi-type {ansi |cisco | q9330a}| 设置Frame Relay LMI类型 |<br>| interface interface-type interface-number subinterface-number [ frame-relay map protocol protocol-address dlci [broadcast] | 映射协议地址与DLCI |<br>| frame-relay interface-dlci dlci [broadcast] | 设置FR DLCI编号|<br>摘抄书中部分配置信息:<br>配置R1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">encapsulation frame-relay (简写encap frame-reply)</div><div class="line">clockrate 64000</div><div class="line">frame-relay lmi-type cisco</div><div class="line">no frame-replay inverse-arp (关闭帧中继逆向ARP)</div></pre></td></tr></table></figure></p>
<p><strong>以上就是对广域网接入的小小见解。</strong></p>
]]></content>
      
        <categories>
            
            <category> 网络攻防 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[访问控制列表ACL]]></title>
      <url>/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%88%97%E8%A1%A8ACL.html/</url>
      <content type="html"><![CDATA[<p>为什么需要ACL，无非是进行访问控制罢了。这种技术从路由器逐步推广到交换机上进行使用。<br><a id="more"></a><br>ACL对入站或出站的通信进行过滤。ACL的局限性是不能对路由器本身发出的通信进行过滤，因此在路由器上执行ping或trace、route命令，或者通过路由器远程连接(telnet)另外一个网络设备，应用于路由器端口的ACL命令不能过滤这些通信。<br>ACL基本原则:</p>
<ul>
<li>先匹配原则</li>
<li>排序原则</li>
<li>默认丢弃原则<br>我们知道ACL分为标准ACL和扩展ACL。</li>
</ul>
<h2 id="标准ACL"><a href="#标准ACL" class="headerlink" title="标准ACL"></a>标准ACL</h2><p>标准编号范围:1~99,1300~1999。<br>命令格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Router(config)#access-list 编号 permit|deny 单个IP|&#123;网络地址 反掩码&#125;</div></pre></td></tr></table></figure></p>
<p>激活ACL命令(进入端口应用ACL)<br>in表示进入端口的分组(入站)，out表示端口输出的分组(出站)。<br>我们可以这样理解，在针对配置的设备来说，该端口经过该设备传送即为入站，反之端口远离该设备即为出站。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Router(config)#interface 端口号</div><div class="line">Router(config-if)#ip access-group acl编号 in|out</div></pre></td></tr></table></figure></p>
<p>通配符掩码的例子</p>
<table><br>        <tr><br>            <th>IP地址</th><br>            <th>通配符掩码</th><br>            <th>匹配</th><br>        </tr><br>        <tr><br>            <th>0.0.0.0</th><br>            <th>255.255.255.255</th><br>            <th>匹配任何地址(关键字any)</th><br>        </tr><br>        <tr><br>            <th>172.16.1.1</th><br>            <th>0.0.0.0    </th><br>            <th>匹配host 172.16.1.1(匹配单个主机)</th><br>        </tr><br>    </table>




<p>标准ACL默认配置<br><code>access-list 编号 deny any</code></p>
<h2 id="扩展ACL"><a href="#扩展ACL" class="headerlink" title="扩展ACL"></a>扩展ACL</h2><p>标准编号范围:1~99,1300~1999。<br>命令格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Router(config)#access-list 编号 permit|deny 协议类型 源网络地址 反掩码 [控制信息]目的地址 反掩码 [控制信息] [log]</div></pre></td></tr></table></figure></p>
<p>协议类型:tcp、udp、icmp、ip<br>对于TCP和UDP协议如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Router(config)#access-list 编号 permit|deny tcp|udp 源网络地址 反掩码 目的地址 反掩码 [操作符 端口|关键字] [established] [log]</div></pre></td></tr></table></figure></p>
<p>激活ACL命令同标准ACL一致<br>实例配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Router#conf t</div><div class="line">Router(config)#access-list 100 permit tcp any 172.16.0.0 0.0.255.255 established log</div><div class="line">Router(config)#access-list 100 permit udp host 172.16.1.1 eq dns log</div><div class="line">Router(config)#access-list 100 permit tcp 172.17.0.0 0.0.255.255 host 172.16.1.2 eq telnet log</div><div class="line">Router(config)#access-list 100 permit icmp any 172.16.0.0 0.255.255.255 echo-reply log</div><div class="line">Router(config)#access-list 100 deny ip any any log</div><div class="line">Router(config)#interface ethernet0</div><div class="line">Router(config-if)#ip access-group 100 in</div></pre></td></tr></table></figure></p>
<p>标准ACL默认配置<br><code>access-list 编号 deny ip any any</code></p>
<p><strong>以上就是我对ACL的小小见解。</strong></p>
]]></content>
      
        <categories>
            
            <category> 网络攻防 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[路由器的基本配置]]></title>
      <url>/%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE.html/</url>
      <content type="html"><![CDATA[<p>路由器是网络异种网络互联与多个子网互联的重要设备。简单来说，路由器可以将不同的局域网进行互联和通信。<br><a id="more"></a></p>
<h3 id="路由器疑点"><a href="#路由器疑点" class="headerlink" title="路由器疑点"></a>路由器疑点</h3><p>相比大家都路由器设备并不陌生，日常生活随处可见。<br>明明处于三层的路由器设备为何运用会比交换机普遍呢？<br>家庭日常使用的路由器为何需要连接不同子网呢？<br>当我们使用路由器上网时我们应当处于同一个局域网中？<br>这些疑惑笔者日后定会前来解答。</p>
<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><h5 id="配置IP地址"><a href="#配置IP地址" class="headerlink" title="配置IP地址"></a>配置IP地址</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Rouer&gt;enable</div><div class="line">Router#config t</div><div class="line">Router(config)#interface fastethernet0/1</div><div class="line">Router(config-if)#ip address 192.168.1.11 255.255.255.0</div><div class="line">Router(config-if)no shutdown</div><div class="line">Router(config-if)#end</div><div class="line">Router#show running-config</div></pre></td></tr></table></figure>
<h5 id="配置终端服务器"><a href="#配置终端服务器" class="headerlink" title="配置终端服务器"></a>配置终端服务器</h5><p>对于大型网络需要使用多个路由器和交换设备，如果对于每一个设备进行一一通过控制台端口配置是很麻烦的，所以产生终端服务器(路由器功能的一种)来实现用一台PC同时访问多个网络设备。<br>在此呢笔者不进行阐述了，无非是通过切换对每一个设备进行配置罢了。</p>
<h5 id="配置静态路由"><a href="#配置静态路由" class="headerlink" title="配置静态路由"></a>配置静态路由</h5><p>我们可以理解路由器不是直连的网络不能相互连通，但是我们可以人为的指定一条路径告诉路由器如何访问。<br>笔者疑惑的是静态路由是否只能间隔一个路由设备才能使用，由于实验的欠缺，在此立个flag。</p>
<h6 id="IPv4静态路由"><a href="#IPv4静态路由" class="headerlink" title="IPv4静态路由"></a>IPv4静态路由</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">R2#config t</div><div class="line">R2(config)#ip route 192.168.1.0 255.255.255.0 10.1.1.1</div><div class="line">R2(config)#end</div></pre></td></tr></table></figure>
<h6 id="IPv6静态路由"><a href="#IPv6静态路由" class="headerlink" title="IPv6静态路由"></a>IPv6静态路由</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">R2#config t</div><div class="line">R2(config)#ip 2005:CCCC::/64 Serial0/2/0</div><div class="line">R2(config)#end</div></pre></td></tr></table></figure>
<h3 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h3><p>我们仔细想想，为什么需要路由协议？无非是告诉路由器如何选择路由线路，因此产生了<code>距离矢量</code>、<code>链路状态</code>、<code>平衡混合</code>等选择方式的协议了。<br>原本根据路由选择协议的应用范围，可划分为内部网关协议、外部网关协议和核心网关协议(软考未涉及)三大类。</p>
<h4 id="内部网关协议"><a href="#内部网关协议" class="headerlink" title="内部网关协议"></a>内部网关协议</h4><p>我们可以理解在自治系统内部进行选择的路由协议。</p>
<h5 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h5><p>用跳数来作为唯一的度量值。</p>
<table><br>        <tr><br>            <th>命令</th><br>            <th>功能</th><br>        </tr><br>        <tr><br>            <th>router rip</th><br>            <th>指定使用RIP协议</th><br>        </tr><br>        <tr><br>            <th>network 网络地址</th><br>            <th>指定相连的网段</th><br>        </tr><br>        <tr><br>            <th>show ip route</th><br>            <th>查看路由表信息</th><br>        </tr><br>        <tr><br>            <th>show ip route igrp</th><br>            <th>查看IGRP协议的路由信息</th><br>        </tr><br></table>


<p>至于配置案例在此就不叙述了。</p>
<h5 id="IGRP协议"><a href="#IGRP协议" class="headerlink" title="IGRP协议"></a>IGRP协议</h5><p>与RIP协议配置不同的是，IGRP需要配置链路的带宽，毕竟带宽也是IGRP协议的度量值之一。</p>
<table><br>    <tr><br>        <th>命令</th><br>        <th>功能</th><br>    </tr><br>    <tr><br>        <th>route igrp 自治系统号</th><br>        <th>指定使用IGRP协议</th><br>    </tr><br>    <tr><br>        <th>network 网络地址</th><br>        <th>指定相连的网段</th><br>    </tr><br>    <tr><br>        <th>show ip route</th><br>        <th>查看路由表信息</th><br>    </tr><br>    <tr><br>        <th>show ip route igrp</th><br>        <th>查看IGRP协议的路由信息</th><br>    </tr><br></table>

<p>至于配置案例在此就不叙述了。<br>需要注意的是:使用IGRP协议，所涉及的路由器的自治系统号必须相同，否则彼此的路由信息将不被互相传递和学习。(自治系统号使用数字即可)</p>
<h5 id="OSPF协议"><a href="#OSPF协议" class="headerlink" title="OSPF协议"></a>OSPF协议</h5><p>通过链路状态(接口状态)来建立路由关系，适合大型网络使用。</p>
<p><table><br>    <tr><br>        <th>命令</th><br>        <th>功能</th><br>    </tr><br>    <tr><br>        <th>route ospf 进程ID</th><br>        <th>指定使用OSPF协议</th><br>    </tr><br>    <tr><br>        <th>network 网络地址 反掩码 area 区域号</th><br>        <th>指定相连的网段</th><br>    </tr><br>    <tr><br>        <th>show ip route</th><br>        <th>查看路由器信息</th><br>    </tr><br>    <tr><br>        <th>show ip route ospf</th><br>        <th>查看OSPF协议的路由信息</th><br>    </tr><br></table><br>至于配置案例在此就不叙述了。<br>需要注意的是:使用OSPF协议，每台路由器的OSPF所使用的进程号并不需要一致。(进程号使用数字即可)</p>
<h5 id="EIGRP协议"><a href="#EIGRP协议" class="headerlink" title="EIGRP协议"></a>EIGRP协议</h5><p>EIGRP是增强版的IGRP协议，它属于平衡混合协议。它的相关命令与IFGRP类似。(软考对于EIPGRP知识点涉及较少)</p>
<p><table><br>    <tr><br>        <th>命令</th><br>        <th>功能</th><br>    </tr><br>    <tr><br>        <th>router eigrp 自治系统号</th><br>        <th>指定使用OSPF协议</th><br>    </tr><br>    <tr><br>        <th>network 网络地址 [反掩码]</th><br>        <th>指定相连的网段</th><br>    </tr><br>    <tr><br>        <th>no auto-summay</th><br>        <th>关闭自动汇总功能</th><br>    </tr><br>    <tr><br>        <th>show ip route eigrp</th><br>        <th>查看EIGRP协议的路由信息</th><br>    </tr><br></table><br>至于配置案例在此就不叙述了。<br>需要注意的是:<br>    使用EIGRP协议，一般都需要关闭自动汇总功能。<br>    在这EIGRP使用的是反掩码，如果使用的是主网地址(A、B、C类的网络，就是掩码为8、16、24位的)可以省略反掩码。<br>(涉及反掩码的协议:OSPF、EIGRP、ACL)</p>
<h4 id="外部网关协议"><a href="#外部网关协议" class="headerlink" title="外部网关协议"></a>外部网关协议</h4><p>BGP:路径向量协议，在BGP路径选择信息中都带有AS号码的序列，它指出一个路由已通过的路径。<br>BGP把TCP当作它的传送协议，端口号179，这样就能给个保证它所有的传送是可靠的。<br>它本身是属于网路层协议。</p>
<p><strong>以上就是对路由器协议的小小见解。</strong></p>
]]></content>
      
        <categories>
            
            <category> 网络攻防 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网络常用设备及介绍]]></title>
      <url>/%E7%BD%91%E7%BB%9C%E5%B8%B8%E7%94%A8%E8%AE%BE%E5%A4%87%E5%8F%8A%E4%BB%8B%E7%BB%8D.html/</url>
      <content type="html"><![CDATA[<p>我们能够理解即使虚拟的网络也需要底层的物理设备作为承载！<br><a id="more"></a></p>
<h2 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h2><p>处于物理层的中继器，作用比较单一，对接收信号进行再生和发送。它不会解释和改变接收到的数字信息。<br>但是在以太网中中继器的数量是有限的，最多使用4个中继器，即5个网段，3个网段接PC，这就是<code>5-4-3规则</code>。</p>
<h2 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h2><p>即Hub，工作原理同中继器一致，简单来说是一个多端口中继器，它把一个端口上收到的数据广播发生到其他所有的端口上。</p>
<h2 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h2><p>工作与数据链路层，用于连接两个局域网段。它通过分析数据帧的地址字段，来决定是否把收到的帧转发给另一个网段。网桥用于局域网互联。</p>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>多端口网桥，每一个端口都可以连接一个局域网。(二层交换机用于局域网互联)</p>
<h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>常用于广域网互联，通过逻辑地址(IP地址)转发网络间的信息，完成异构网络之间的互通互联。但是只能连接使用相同网络层协议的子网。</p>
<h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p>工作于4-7层，是最复杂的网络互联设备了，用于连接网络上执行不同协议的子网。</p>
<p><strong>以上就是对网络设备的小小见解。</strong></p>
]]></content>
      
        <categories>
            
            <category> 网络攻防 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[策略路由]]></title>
      <url>/%E7%AD%96%E7%95%A5%E8%B7%AF%E7%94%B1.html/</url>
      <content type="html"><![CDATA[<p>在我认为策略路由是一种强化控制方式，就默认而言直接路由、静态路由、默认路由和各种动态协议所生成的路由条目，路由器远可以将数据分组从其源地址转发到目的地址。<br>但是人们的强权意识觉得这远远是不够的，因此策略路由(Policy Based Routing,PBR)就用来对分组的转发和路由的传播进行精准控制。<br><a id="more"></a><br>在此呢笔者仅仅介绍涉及路由映射表的命令。当然书中的实例对于理解大有帮助。</p>
<h2 id="1-route-map命令"><a href="#1-route-map命令" class="headerlink" title="1. route-map命令"></a>1. route-map命令</h2><p>创建一个路由映射表(定义路由图)</p>
<blockquote>
<p>route-map 映射表名称 [permit | deny] 路由映射表的序列号</p>
</blockquote>
<p>使用<code>no route-map 映射表名称 [permit | deny] 路由映射表的序列号</code>删除指定的路由映射表</p>
<h2 id="2-match命令"><a href="#2-match命令" class="headerlink" title="2. match命令"></a>2. match命令</h2><p>用于指定分组所需要匹配的条件(定义匹配条件)<br>1) match ip address</p>
<blockquote>
<p>match ip address {acl编号 | 名称}</p>
</blockquote>
<p>2) match length </p>
<blockquote>
<p>match length 最小长度 最大长度</p>
</blockquote>
<h2 id="3-set命令"><a href="#3-set命令" class="headerlink" title="3. set命令"></a>3. set命令</h2><p>指定对匹配的分组进行转发的方式和规则(定义转发规则)<br>1) set ip next-hop</p>
<blockquote>
<p>set ip next-hop 下一跳地址</p>
</blockquote>
<p>2) set interface</p>
<blockquote>
<p>set interface 指定接口</p>
</blockquote>
<p>3) set ip default next-hop</p>
<blockquote>
<p>set interface 默认下一跳转发地址</p>
</blockquote>
<p>4) set default interface</p>
<blockquote>
<p>set default interface 指定接口</p>
</blockquote>
<h2 id="4-在接口上应用策略路由命令"><a href="#4-在接口上应用策略路由命令" class="headerlink" title="4. 在接口上应用策略路由命令"></a>4. 在接口上应用策略路由命令</h2><p>(应用于接口上)<br>ip policy route-map</p>
<blockquote>
<p>ip policy route-map 映射表名称/标记</p>
</blockquote>
<p>对本地路由器产生的分组应用策略路由，需要使用:</p>
<blockquote>
<p>ip local policy route-map 映射表名称/标记</p>
</blockquote>
<h2 id="5-查看路由策略命令"><a href="#5-查看路由策略命令" class="headerlink" title="5. 查看路由策略命令"></a>5. 查看路由策略命令</h2><p>(验证策略路由)<br>1) show route-map</p>
<blockquote>
<p>show route-map [映射表名称 | all]</p>
</blockquote>
<p>2) show ip policy</p>
<blockquote>
<p>show ip policy 地图名称</p>
</blockquote>
<p>3) debug ip policy</p>
<blockquote>
<p>debug ip policy</p>
</blockquote>
<p>实例在此省略，详细见课本。</p>
<p><strong>以上就是对策略路由的小小见解。</strong></p>
]]></content>
      
        <categories>
            
            <category> 网络攻防 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[交换机的基本配置]]></title>
      <url>/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE.html/</url>
      <content type="html"><![CDATA[<p>什么是交换机？交换机的作用是什么？以及交换机的基本配置有哪些？这些是我需要思考的。(注意:我们这里所说的是二层交换机)<br><a id="more"></a><br>交换机是软考的必考点，但是理论看多了就有些迷茫，不明白底层的一些含义及想法。</p>
<h2 id="简介交换机"><a href="#简介交换机" class="headerlink" title="简介交换机"></a>简介交换机</h2><p>交换机也叫交换式集线器，作用和集线器大题相同。但是为何集线器远远没有交换机出名呢？<br>这源于它们俩的特性不同，集线器采用共享带宽，而交换机采用独占带宽。所以交换机能获得的带宽，至于原理笔者也不能理解。</p>
<h2 id="交换机作用"><a href="#交换机作用" class="headerlink" title="交换机作用"></a>交换机作用</h2><p>交换机的作用是用来连接局域网(LAN)内的多个节点，用于局域网内的数据交换，因此它主要运用于组建局域网使用。<br>交换机有许多接口，不同的接口可以连接不同的主机，因此我们可以轻易的理解到交换机使相应的主机处于同一个局域网中。</p>
<h2 id="交换机分类"><a href="#交换机分类" class="headerlink" title="交换机分类"></a>交换机分类</h2><p>按适用范围划分：接入层交换机、汇聚层交换机、核心层交换机</p>
<h2 id="常用配置命令"><a href="#常用配置命令" class="headerlink" title="常用配置命令"></a>常用配置命令</h2><h3 id="配置enable口令、密码和主机名"><a href="#配置enable口令、密码和主机名" class="headerlink" title="配置enable口令、密码和主机名"></a>配置enable口令、密码和主机名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Switch&gt;</div><div class="line">Switch&gt;enable   (简写en)</div><div class="line">Switch#config terminal</div><div class="line">Switch(config)#enable password cisco</div><div class="line">Switch(config)#enable secret cisco1</div><div class="line">Switch(config)#hostname C2950</div><div class="line">C2950(config)#end</div><div class="line">C2950#</div></pre></td></tr></table></figure>
<h3 id="配置IP地址、默认网关、域名和域名服务器"><a href="#配置IP地址、默认网关、域名和域名服务器" class="headerlink" title="配置IP地址、默认网关、域名和域名服务器"></a>配置IP地址、默认网关、域名和域名服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">C2950(config)#ip address 192.168.1.1 255.255.255.0</div><div class="line">C2950(config)#ip default-gatway 192.168.1.254</div><div class="line">C2950(config)#ip domain-name cisco.com</div><div class="line">C2950(config)#ip name-senver 200.0.0.1</div><div class="line">C2950(config)#end</div></pre></td></tr></table></figure>
<h3 id="配置端口属性"><a href="#配置端口属性" class="headerlink" title="配置端口属性"></a>配置端口属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">C2950(config)#interface fastethernet0/1     (简写int f0/1)</div><div class="line">C2950(config-if)#speed ?</div><div class="line">C2950(config-if)#speed 100</div><div class="line">C2950(config-if)#duplex ?</div><div class="line">C2950(config-if)#euplex full</div><div class="line">C2950(config-if)#description TO_PC1</div><div class="line">C2950(config-if)#^Z</div><div class="line">C2950#show interface fastethernet0/1</div><div class="line">C2950#show interface fastethernet0/1 status</div></pre></td></tr></table></figure>
<h3 id="配置和查看MAC地址表"><a href="#配置和查看MAC地址表" class="headerlink" title="配置和查看MAC地址表"></a>配置和查看MAC地址表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">C2950(config)#mac-address-table ?</div><div class="line">C2950(config)#mac-address-table aging-time 100</div><div class="line">C2950(config)#mac-address-table permanent 0000.0c01.bbcc f0/3</div><div class="line">C2950(config)#mac-address-table restricted static 0000.0c02.bbcc f0/3 f0/7</div><div class="line">C2950(config)#end</div><div class="line">C2950#show mac-address-table</div><div class="line">C2950#show mac-address-table restricted static</div></pre></td></tr></table></figure>
<h2 id="配置和管理VLAN"><a href="#配置和管理VLAN" class="headerlink" title="配置和管理VLAN"></a>配置和管理VLAN</h2><h3 id="什么是VLAN"><a href="#什么是VLAN" class="headerlink" title="什么是VLAN"></a>什么是VLAN</h3><p>VLAN是用于把物理上直接相连的网络从逻辑上划分为多个子网。交换机将主机连接在同一个局域网，如果主机过多就会不便于管理，尤其可能形成”广播风暴”之类的现象，如果我们可以将它们划分，那么它们就可以共享一个冲突域，而不是同享一个广播域了。(默认配置下，所有接口处于可用状态并且都属于VLAN1)</p>
<h3 id="VLAN的作用"><a href="#VLAN的作用" class="headerlink" title="VLAN的作用"></a>VLAN的作用</h3><p>VLAN划分了网络，那么它就可以对局域网里面的网络进行合理的管理了。对于区分用户主体、路径都是可以自由配置的。为了获得这些能力，我们不能不学习一些协议了，它们分别是<code>VTP</code>、<code>VLAN中继</code>和<code>VLAN配置</code>了。</p>
<h5 id="VLAN中继"><a href="#VLAN中继" class="headerlink" title="VLAN中继"></a>VLAN中继</h5><p>VLAN中继(VLAN Trunk)也称为VLAN主干，在交换机与交换机或交换机与路由器之间连接的端口上配置中继模式，使得属于不同的VLAN的数据库都可以通过这条中继链路进行传播。<br>这个很好理解，不同的VLAN始终是需要通信的，所有这个问题必须解决。但是笔者疑惑的是不同的VLAN之间原本要引入第三层交换技术才可以解决，VLAN处理数据帧那VLAN中继应该是第二次的协议，如何处理不同VLAN通信。</p>
<h5 id="VTP协议"><a href="#VTP协议" class="headerlink" title="VTP协议"></a>VTP协议</h5><p>VTP协议可以维护VLAN信息全网的一致性、VTP有三种工作模式，客户机模式client、服务器模式server、透明模式transparent，详细的差别点这里就不叙述了。</p>
<h6 id="配置2950A交换机为服务器模式"><a href="#配置2950A交换机为服务器模式" class="headerlink" title="配置2950A交换机为服务器模式"></a>配置2950A交换机为服务器模式</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">2950A#</div><div class="line">2950A#vlan database</div><div class="line">2950A#vtp ?</div><div class="line">2950A(vlan)#vtp server</div><div class="line">Setting device to VTP SERVER mode.</div><div class="line">2950A(vlan)#vtp domain vtpserver</div><div class="line">Changing VTP domain name from NULL to vtpserver.</div><div class="line">2950A(vlan)#vtp pruning</div><div class="line">Pruning switched ON</div><div class="line">2950A(vlan)#exit</div><div class="line">APPLY completed .Exiting...</div><div class="line">2950A#show vtp status</div></pre></td></tr></table></figure>
<h6 id="配置2950A交换机为客户机模式"><a href="#配置2950A交换机为客户机模式" class="headerlink" title="配置2950A交换机为客户机模式"></a>配置2950A交换机为客户机模式</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">2950A#</div><div class="line">2950A#vlan database</div><div class="line">2950A(vlan)#vtp client</div><div class="line">Setting device to VTP CLIENT mode.</div><div class="line">2950A(vlan)#exit</div></pre></td></tr></table></figure>
<h6 id="配置VLAN-Trunk端口"><a href="#配置VLAN-Trunk端口" class="headerlink" title="配置VLAN Trunk端口"></a>配置VLAN Trunk端口</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Switch#config terminal</div><div class="line">Switch(config)#interface f0/24</div><div class="line">Switch(config-if)#switchport mode trunk</div><div class="line">Switch(config-if)#switchport trunk allow vlan all</div><div class="line">Switch(config-if)#exit</div><div class="line">Switch(config)#exit</div><div class="line">Switch#</div></pre></td></tr></table></figure>
<h3 id="配置VALN"><a href="#配置VALN" class="headerlink" title="配置VALN"></a>配置VALN</h3><h5 id="创建VLAN"><a href="#创建VLAN" class="headerlink" title="创建VLAN"></a>创建VLAN</h5><p>VLAN信息可以在服务器模式或透明模式交换机创建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">2950A#</div><div class="line">2950A#vlan database</div><div class="line">2950A(vlan)#vlan 2</div><div class="line">VLAN 2 added:</div><div class="line">    Name:VLAN002</div><div class="line">2950A(vlan)#vlan 3 name vlan3</div><div class="line">VLAN 3 added:   Name vlan3</div><div class="line">2950A(vlan)#exit</div></pre></td></tr></table></figure></p>
<h5 id="将端口添加到某VLAN中"><a href="#将端口添加到某VLAN中" class="headerlink" title="将端口添加到某VLAN中"></a>将端口添加到某VLAN中</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Switch#config terminal</div><div class="line">Switch(config)#interface f0/9</div><div class="line">Switch(config-if)#switchport mode access</div><div class="line">Switch(config-if)#switchport access vlan2</div><div class="line">Switch(config-if)#exit</div><div class="line">Switch(config)#interface f0/10</div><div class="line">Switch(config-if)#switchport mode access</div><div class="line">Switch(config-if)#switchport access vlan3</div><div class="line">Switch(config-if)#exit</div><div class="line">Switch(config)#exit</div><div class="line">Switch#show vlan</div><div class="line">Switch#</div></pre></td></tr></table></figure>
<h2 id="生成树协议配置"><a href="#生成树协议配置" class="headerlink" title="生成树协议配置"></a>生成树协议配置</h2><h3 id="什么是生成树"><a href="#什么是生成树" class="headerlink" title="什么是生成树"></a>什么是生成树</h3><p>由于交换机之间需要冗余连接(当然这可以提高网络的可靠性)，因此对于数据帧的转发就可能存在网络环路的现象产生了(多个Trunk端口)，这种现象的产生对于网络往往是致命的，严重影响其他正常数据的传播。<br>因此我们可以通过一直规定告诉交换机哪个端口可以用于转发，哪些会被阻断。于是我们的<code>STP</code>登上了舞台。</p>
<h3 id="生成树配置"><a href="#生成树配置" class="headerlink" title="生成树配置"></a>生成树配置</h3><p>对于生成树我们可以根据<code>端口权值</code>和<code>路径值</code>实现负载均衡。</p>
<h5 id="端口权值-port-priority"><a href="#端口权值-port-priority" class="headerlink" title="端口权值(port-priority)"></a>端口权值(port-priority)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Switch#config terminal</div><div class="line">Switch(config)#interface f0/9</div><div class="line">Switch(config-if)#spanning-tree vlan 1 port-priority 10</div><div class="line">Switch(config-if)#spanning-tree vlan 2 port-priority 10</div><div class="line">Switch(config-if)#end</div><div class="line">Switch#copy running-config startup-config</div></pre></td></tr></table></figure>
<h5 id="路径值-cost"><a href="#路径值-cost" class="headerlink" title="路径值(cost)"></a>路径值(cost)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Switch#config terminal</div><div class="line">Switch(config)#interface f0/9</div><div class="line">Switch(config-if)#spanning-tree vlan 1 cost 30</div><div class="line">Switch(config-if)#spanning-tree vlan 1 cost 30</div><div class="line">Switch(config-if)#exit</div><div class="line">Switch#</div></pre></td></tr></table></figure>
<p><strong>以上就是对交换机配置的小小见解。</strong></p>
]]></content>
      
        <categories>
            
            <category> 网络攻防 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C语言函数指针]]></title>
      <url>/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88.html/</url>
      <content type="html"><![CDATA[<p>C语言的高级特性,关于指针的用法我想是不是应该认真了解下哦！<br><a id="more"></a><br>指针是C语言的灵魂。</p>
<h3 id="函数指针定义形式"><a href="#函数指针定义形式" class="headerlink" title="函数指针定义形式"></a>函数指针定义形式</h3><p>定义形式:<br>类型名 (* 指针变量名)(参数类型1，参数类型2，…);<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int (*pf)(int,char);</div></pre></td></tr></table></figure></p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>可以用一个原型匹配的函数的名字给一个函数指针赋值。<br>要通过函数指针调用它所指向的函数，写法为:<br>函数指针名(实参表);</p>
<h4 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">void PrintMin(int a,int b)</div><div class="line">&#123;</div><div class="line">    if(a&lt;b)</div><div class="line">        printf(&quot;%d&quot;,a);</div><div class="line">    else</div><div class="line">        printf(&quot;%d&quot;,b);</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    void (* pf)(int, int);</div><div class="line">    int x = 4,y = 5;</div><div class="line">    pf = PrintMin;</div><div class="line">    pf(x,y);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="函数指针和qsort库函数"><a href="#函数指针和qsort库函数" class="headerlink" title="函数指针和qsort库函数"></a>函数指针和qsort库函数</h3><p>C语言快速排序库函数:<br>void qsort(void <em>base,int nelem,unsigned int width,int( </em> pfCompare)(const void <em>,const void </em>));<br>可以对任意类型的数组进行排序<br>base:待排序数组的起始地址；<br>nelem:待排序数组的元素个数；<br>width:待排序数组的每个元素的大小(以字节为单位);<br>pfCompare:比较函数的地址</p>
<p>注意:pfCompare需要自己编写<br>格式:int 函数名(const void <em> elem1,const void </em> elem2);</p>
<p>排序就是一个不断比较并交换位置的过程。<br>比较函数编写规则:</p>
<ul>
<li>如果<em> elem1应该排在 </em> elem2前面，则函数返回值是负整数</li>
<li>如果<em> elem1和 </em> elem2哪个排在前面都行，则函数返回0</li>
<li>如果<em> elem1应该排在 </em> elem2后面，则函数返回值是正整数</li>
</ul>
<h4 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h4><p>调用qsort库函数，将一个unsigned int数组按照个位数从小到大进行排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">int MyCompare(const void * elem1,const void *elem2)</div><div class="line">&#123;</div><div class="line">    unsigned int * p1,* p2;</div><div class="line">    p1 = (unsigned int *)elem1;//强制类型转换，&quot;elem1&quot;非法</div><div class="line">    p2 = (unsigned int *)elem2;//&quot;elem2&quot;非法</div><div class="line">    return (*p1 % 10) - (*p2 % 10);</div><div class="line">&#125;</div><div class="line">#define NUM 5</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    unsigned int an[NUM] = &#123;8,123,11,10,4&#125;;</div><div class="line">    qsort(an,NUM,sizeof(unsigned int),MyCompare);</div><div class="line">    for(int i = 0;i &lt; NUM;i++)</div><div class="line">        printf(&quot;%d&quot;,an[i]);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">10 11 123 4 8</div></pre></td></tr></table></figure></p>
<p><strong>完成coursera里面的课程设计，我想这既是机遇又是挑战</strong></p>
]]></content>
      
        <categories>
            
            <category> C语言 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[C语言命令行参数]]></title>
      <url>/C%E8%AF%AD%E8%A8%80%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0.html/</url>
      <content type="html"><![CDATA[<p>C语言的高级特性,如何利用main函数的两个参数。<br><a id="more"></a><br>读取程序运行的命令行参数。</p>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>函数原型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int main(int agrc,char * argv[])</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>argc:代表启动程序时，命令行参数的格式。C/C++语言规定，可执行程序程序本身的文件名，也算一个命令行参数；因此，argc的值至少为1.<br>argv:指针数组，其中的每个元素都是一个char *类似的指针，该指针指向一个字符串，这个字符串里就存放着命令行参数。<br>例如，argv[0]指向的字符串就是第一个命令行参数，即可指向程序的文件名，argv[1]指向第二个命令行参数，argv[2]指向第三个命令行参数…….。</p>
<h4 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">int main(int argc,char * argv[])</div><div class="line">&#123;</div><div class="line">    for(int i = 0;i &lt; argc;i++)</div><div class="line">        printf(&quot;%s\n&quot;,argv[i]);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将上面的程序编译成sample.exe,然后在控制套窗口敲:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sample para1 para2 s.txt 5 &quot;hello world&quot;</div></pre></td></tr></table></figure></p>
<p><strong>完成coursera里面的课程设计，我想这既是机遇又是挑战</strong></p>
]]></content>
      
        <categories>
            
            <category> C语言 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[将python转换成可执行程序exe]]></title>
      <url>/%E5%B0%86python%E8%BD%AC%E6%8D%A2%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8Fexe.html/</url>
      <content type="html"><![CDATA[<p>python脚本很方便简洁，但是推广可能还是exe文件有市场吧！<br><a id="more"></a><br>学过很多解释性语言都有一种感觉，那就是快捷上手。给人感觉不错，但是还是对图形化程序念念不忘。</p>
<h3 id="python脚本如何转为可执行程序"><a href="#python脚本如何转为可执行程序" class="headerlink" title="python脚本如何转为可执行程序"></a>python脚本如何转为可执行程序</h3><p>对于python脚本转换成有三个有名的程序:py2exe,pyinstaller(推荐),cxfreeze。</p>
<h4 id="py2exe"><a href="#py2exe" class="headerlink" title="py2exe"></a>py2exe</h4><p>在windows下安装py2exe，直接使用pip即可:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install py2exe</div></pre></td></tr></table></figure></p>
<p>然后在python文件前面写上注释:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># python file to exe in window</div><div class="line"># py2exe.py</div></pre></td></tr></table></figure></p>
<p>只要执行命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python py2exe.py py 文件名</div></pre></td></tr></table></figure></p>
<h4 id="pyinstaller-推荐"><a href="#pyinstaller-推荐" class="headerlink" title="pyinstaller(推荐)"></a>pyinstaller(推荐)</h4><p>网上对于pyinstaller的看法比py2exe的看法好多了，没办法我想肯定有它的道理。<br><a href="http://www.pyinstaller.org/" target="_blank" rel="external">官网</a><br>安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install pyinstaller</div></pre></td></tr></table></figure></p>
<p>转换成exe<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pyinstaller python脚本文件名</div></pre></td></tr></table></figure></p>
<p>然后生成的文件里面就有可执行文件了。<br>文件夹路径在:<code>/dist/文件名/文件名.exe</code><br>注意:这种转换需要dll以及其他文件依赖，当然我们还是可以转换成一个独立的exe文件的。<br>加上一个参数<code>-F</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pyinstaller -F python脚本文件名</div></pre></td></tr></table></figure>
<p>这样文件夹里面就只有单独的可执行文件了。</p>
<h4 id="cxfreeze"><a href="#cxfreeze" class="headerlink" title="cxfreeze"></a>cxfreeze</h4><p>对于这个网上并没有太多描述，我想还是专注pyinstaller就可以了。<br><a href="http://cx-freeze.readthedocs.io/en/latest/index.html" target="_blank" rel="external">官网</a></p>
<p><strong>我想先熟练某一种就是最好的吧！当然学习python常用模块刻不容缓</strong></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[linux命令简单操作]]></title>
      <url>/linux%E5%91%BD%E4%BB%A4%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C.html/</url>
      <content type="html"><![CDATA[<p>用户知道自己想要什么，也明白自己在做什么，并且会为自己的行为负责。<br><a id="more"></a><br>很多时候我也不知道为什么我需要学习linux，但是我知道学习linux也将会改变我对操作系统原有的一些想法和操作吧。</p>
<h3 id="赋予文件夹所有权限"><a href="#赋予文件夹所有权限" class="headerlink" title="赋予文件夹所有权限"></a>赋予文件夹所有权限</h3><p>此文件夹及以下的所有子目录和文件权限都会变为777，及任何权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod R 777 /文件夹名</div></pre></td></tr></table></figure></p>
<h3 id="新建文本"><a href="#新建文本" class="headerlink" title="新建文本"></a>新建文本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi 文件名(可包括文件路径和后缀)</div></pre></td></tr></table></figure>
<h3 id="删除文件或文件夹"><a href="#删除文件或文件夹" class="headerlink" title="删除文件或文件夹"></a>删除文件或文件夹</h3><ul>
<li>删除home目录下的test目录<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm -rf /home/test       #推荐使用，方便快捷</div></pre></td></tr></table></figure>
</li>
</ul>
<p>f是不提示用户，删除目录下的所有文件。请注意检查路径，输成别的目录就悲剧了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm /home/test</div></pre></td></tr></table></figure>
<p>这种不带参数的删除方法经常会提示无法删除，因为权限不够。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm -r /home/test</div></pre></td></tr></table></figure>
<p>-r是递归的删除参数表中的目录及其子目录。 目录将被清空并且删除。 当删除目录包含的具有写保护的文件时用户通常是被提示的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm -ir /home/test</div></pre></td></tr></table></figure>
<p>-i是交互模式。使用这个选项，rm命令在删除任何文件前提示用户确认。</p>
<p><strong>后期可以补上一些个人常用操作</strong></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用正则表达式完成文本替换]]></title>
      <url>/%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%8C%E6%88%90%E6%96%87%E6%9C%AC%E6%9B%BF%E6%8D%A2.html/</url>
      <content type="html"><![CDATA[<p>之前对vim和正则都存在着一些歪理，认为并不需要如此复杂吧!但是真正需要用到的时候，它们起了很大的作用。<br><a id="more"></a></p>
<blockquote>
<p>在我眼里，没有比正则更难理解的”语言”了。</p>
</blockquote>
<p>其实在所有计算机语言里，汇编也不过尔尔，当你想起你之前写的正则表达式时，你可能会一脸懵逼。当然我还是希望尝试一下的。</p>
<p>对于正则，一直神往，并没有认真去学习多少，大概懂得它的强悍之处。我发现我必须做些什么了。</p>
<p>如何替换html里面的a标签的链接为空呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;li&gt;&lt;a href=&quot;//www.runoob.com/&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;&lt;a href=&quot;/html/html-tutorial.html&quot;&gt;HTML&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;&lt;a href=&quot;/css/css-tutorial.html&quot;&gt;CSS&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;&lt;a href=&quot;/js/js-tutorial.html&quot;&gt;JavaScript&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;&lt;a href=&quot;/jquery/jquery-tutorial.html&quot;&gt;jQuery&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;&lt;a href=&quot;/bootstrap/bootstrap-tutorial.html&quot;&gt;Bootstrap&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;&lt;a href=&quot;/sql/sql-tutorial.html&quot;&gt;SQL&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;&lt;a href=&quot;/mysql/mysql-tutorial.html&quot;&gt;MySQL&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;&lt;a href=&quot;/php/php-tutorial.html&quot;&gt;PHP&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;&lt;a href=&quot;/python/python-tutorial.html&quot;&gt;Python&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;&lt;a href=&quot;/cprogramming/c-tutorial.html&quot;&gt;C&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;&lt;a href=&quot;/cplusplus/cpp-tutorial.html&quot;&gt;C++&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;&lt;a href=&quot;/csharp/csharp-tutorial.html&quot;&gt;C#&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;&lt;a href=&quot;/java/java-tutorial.html&quot;&gt;Java&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;&lt;a href=&quot;/ruby/ruby-tutorial.html&quot;&gt;Ruby&lt;/a&gt;&lt;/li&gt;</div></pre></td></tr></table></figure>
<p>就比如上方的代码而言吧，我想将所有的链接地址为空连接，如果我一个个改的话，肯定特别浪费时间，但是批量操作又没有特点。</p>
<p>最终我知道正则替换方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Find What:&lt;a href=&quot;.*?&quot;&gt;</div><div class="line">Replace With:&lt;a href=&quot;#&quot;&gt;</div></pre></td></tr></table></figure></p>
<p>替换后:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;HTML&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;CSS&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;JavaScript&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;jQuery&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;Bootstrap&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;SQL&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;MySQL&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;PHP&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;Python&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;C&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;C++&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;C#&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;Java&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;Ruby&lt;/a&gt;&lt;/li&gt;</div></pre></td></tr></table></figure></p>
<p>没有太明白为啥需要”.*“加一个小数点呢？这个问题可以研究一下，而”?”可以被省略。所以算是别人对于我正则入门的一个小小的建议吧！<br>对于”*”和”?”日常生活中用的也算比较多吧。</p>
<p>因此可以这么说，正则走起！</p>
<p><strong>以上就是我对正则的小小尝试吧。</strong></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[学习书籍名单]]></title>
      <url>/%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D%E5%90%8D%E5%8D%95.html/</url>
      <content type="html"><![CDATA[<p>书籍是人类进行的阶梯。<br><a id="more"></a><br>也许看过一些书，或者有时候希望看某些书。我觉得我完全可以将这些书找到并且可以附带下载地址。空闲的时候为什么不试试呢？</p>
<h3 id="书籍名单"><a href="#书籍名单" class="headerlink" title="书籍名单"></a>书籍名单</h3><p>《白帽子讲web安全》<br>《web前端黑客技术揭秘》<br>《黑客攻防宝典：web实战篇》<br>《暗战亮剑:黑客渗透于防御全程实录》<br>《backtrack从入门到精通》<br>《黑客攻防技术与案例剖析》<br>《黑客攻防技术与案例剖析》<br>《黑客大曝光第6版》<br>《黑客攻防技术宝典-WEB实战篇》<br>《黑客攻防技术宝典系统实战篇》<br>《黑客WEB脚本攻击与防御技术核心剖析》<br>《黑客渗透笔记完整版》<br>《Q版缓冲区溢出教程》<br>《php漏洞挖掘书籍》<br>《Shellcoder编程揭秘》<br>《黑客防线2009缓冲区溢出攻击与防范专辑》<br>《黑客大曝光：无线网络安全（原书第2版）》<br>《LINUX黑客大曝光（第2版）》<br>《0day安全软件漏洞分析技术》（第一版和第二版）<br>《Binary+Hacks+黑客秘笈100选》<br>《Windows黑客技术揭秘与攻防1C语言篇》<br>《黑武器-linux_BT4无线黑客》<br>《黑客入侵网页攻防修炼》<br>《backtrack4:assuring security by penetration testing》<br>《Web应用安全威胁于防治（基于owasp top 与esapi）<br>《backtrack4:利用渗透测试保证系统安全》<br>《无线网络黑客攻防》<br>《Metasploit渗透测试指南》<br>《网络安全进阶笔记》<br>《Linux网络安全技术与实现(第2版)》<br>《网络安全 王淑江、 等 机械工业出版社 (2007-09出版)》<br>《Web系统安全和渗透性测试基础》<br>《渗透测试实践指南:必知必会的工具与方法》<br>《大中型网络入侵要案直击与防御》<br>《Web安全测试》<br>《Python灰帽子:黑客与逆向工程师的Python编程之道》<br>《SQL Injection Attacks and Defense（SQL注入攻击和防御）》</p>
<p>《SQL Injection Attacks and Possible Remedies（SQL注入攻击和可能的补救措施）》</p>
<p>《SQL: PL-SQL, Transact-SQL, SQL Injection, Database Console Commands, Xleratordb, Foreign Key, Navicat, Cursor,…》</p>
<p>《CEH Certified Ethical Hacker Study Guide [With CDROM]（国家认证的道德黑客学习指南(光盘)》</p>
<p>《The Shellcoder’s Handbook: Discovering and Exploiting Security Holes(这个Shellcoder手册:发现和利用安全漏洞）》</p>
<p>《Sockets, Shellcode, Porting and Coding: Reverse Engineering Exploits and Tool Coding for Security Professionals…（套接字,Shellcode,移植和编码:逆向工程利用和工具编码为安全专家……)》</p>
<p>《Metasploit Toolkit for Penetration Testing, Exploit Development, and Vulnerability Research（Metasploit工具包对渗透测试,利用开发和脆弱性研究)》</p>
<p>《Buffer Overflow Attacks: Detect, Exploit, Prevent（缓冲区溢出攻击:检测,利用,防止）》</p>
<p><strong>后期需要修改一下想看的书或笔记哦！</strong></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Python文本如何转语音]]></title>
      <url>/Python%E6%96%87%E6%9C%AC%E5%A6%82%E4%BD%95%E8%BD%AC%E8%AF%AD%E9%9F%B3.html/</url>
      <content type="html"><![CDATA[<p>Python很强大，也许很多人不相信。但是真正了解到它时，我还是情不自禁的喜欢上了它。<br><a id="more"></a></p>
<blockquote>
<p>人生苦短，我用Python。</p>
</blockquote>
<ul>
<li>使用Speech API</li>
<li>pyttsx方式</li>
</ul>
<p><a href="http://blog.csdn.net/marksinoberg/article/details/52137547#%E5%87%86%E5%A4%87" target="_blank" rel="external">代码Demo参考</a><br>准备</p>
<p>我测试使用的Python版本为2.7.10，如果你的版本是Python3.5的话，这里就不太适合了。<br>在windows上进行测试的话，这里有两种可选的方式：</p>
<p>下载准备:</p>
<ul>
<li><a href="https://www.baidu.com/link?url=Bk-2HPLrqluHb9cDgY3ZpTAOuFuXKqJQwRny7cNq49fe2xzSGgLA3PwcWRYaQniG&amp;wd=&amp;eqid=f4f566790005c88b0000000357a59956" target="_blank" rel="external">pyttsx</a></li>
<li><a href="https://sourceforge.net/projects/pywin32/" target="_blank" rel="external">微软的Speech API,这个需要安装pywin32</a></li>
</ul>
<p>对于这些无非就是下载安装了。</p>
<h4 id="使用Speech-API"><a href="#使用Speech-API" class="headerlink" title="使用Speech API"></a>使用Speech API</h4><p>原理:<br>我们的想法是借助微软的语音接口，所以我们肯定是要进行调用 相关的接口。所以我们需要安装pywin32来帮助我们完成这一个底层的交互。<br>示例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import win32com.client</div><div class="line">speaker = win32com.client.Dispatch(&quot;SAPI.SpVoice&quot;)</div><div class="line">speaker.Speak(&quot;Hello, it works!&quot;)</div></pre></td></tr></table></figure></p>
<p>小总结<br>是的，调用接口来实现语音功能就是这么简单，但是我们不得不来聊一聊这种方式的缺点。</p>
<p>缺点: </p>
<ol>
<li>对中文支持的不够好，仅仅是这一点，估计在中国没几个用它的了。22. 语速不能很好的控制，详细的API介绍可以参照这里API参考</li>
</ol>
<h4 id="pyttsx方式"><a href="#pyttsx方式" class="headerlink" title="pyttsx方式"></a>pyttsx方式</h4><p>示例代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"># coding:utf-8</div><div class="line">import sys</div><div class="line"></div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(&apos;utf8&apos;)</div><div class="line"></div><div class="line">import pyttsx</div><div class="line">engine = pyttsx.init()</div><div class="line">engine.say(&apos;hello world&apos;)</div><div class="line">engine.say(&apos;你好，世界！&apos;)</div><div class="line">engine.runAndWait()</div><div class="line"># 朗读一次</div><div class="line">engine.endLoop()</div></pre></td></tr></table></figure>
<p>小总结:<br>使用pyttsx，我们可以借助其强大的API来实现我们基本的业务需求。很酷吧。</p>
<p><a href="blog.csdn.net/marksinoberg/article/details/52137547">pyttsx深究：</a></p>
<p><strong>以上就是对python文字转语音的小小见解。</strong></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python，语音 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用JS压缩用户上传图片]]></title>
      <url>/%E4%BD%BF%E7%94%A8JS%E5%8E%8B%E7%BC%A9%E7%94%A8%E6%88%B7%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87.html/</url>
      <content type="html"><![CDATA[<p>虽然在”软件测试”部也就是”智慧校园”呆了很久，但我知道这并不是我想要的。无奈厚着脸皮接受一个小小的考验。<br><a id="more"></a><br>说实话，我相信<code>勇敢</code>总是有用的。这不又能学习新的知识了。虽然在某些方面。。。<br>而且证实了一点，公司大神就是多啊！<br><a href="http://blog.csdn.net/iefreer/article/details/53039848?locationNum=7&amp;fps=1" target="_blank" rel="external">代码Demo参考</a><br>对于图片压缩就我个人而言只是概念性问题。当然知识点就在那。</p>
<ul>
<li>源代码分析</li>
<li>HTML5的FileReader接口</li>
<li>canvas drawImage接口</li>
<li>toDataUrl接口转换base64编码</li>
<li>PHP将base64转换成图片</li>
<li>个人注意的点点滴滴</li>
</ul>
<h4 id="源代码分析"><a href="#源代码分析" class="headerlink" title="源代码分析"></a>源代码分析</h4><p>先贴上源代码，其他的不多说:</p>
<blockquote>
<p>index.html:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;</div><div class="line">    &lt;title&gt;图片压缩&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;style type=&quot;text/css&quot;&gt;</div><div class="line">input &#123;</div><div class="line">    margin: 10px 0;</div><div class="line">&#125;</div><div class="line">textarea &#123;</div><div class="line">    width: 100%;</div><div class="line">    height: 300px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;/style&gt;</div><div class="line">&lt;body&gt;</div><div class="line"> &lt;!-- 这里不使用enctype=&quot;multipart/form-data&quot;的含义是禁止文件上传成功--&gt;</div><div class="line">    &lt;form id=&quot;myForm&quot; action=&quot;__URL__/addChk&quot; method=&quot;post&quot;&gt;</div><div class="line">        &lt;input type=&quot;file&quot; value=&quot;image&quot; id=&quot;img_input&quot;  name=&quot;image&quot; /&gt;</div><div class="line">        &lt;textarea id=&quot;result&quot;&gt;&lt;/textarea&gt;</div><div class="line">        &lt;p id=&quot;img_area&quot;&gt;&lt;/p&gt;</div><div class="line">        &lt;input type=&quot;hidden&quot;  name=&quot;&quot;&gt;</div><div class="line"></div><div class="line">    &lt;input type=&quot;button&quot; value=&quot;上传&quot; onclick=&quot;replace()&quot;&gt;</div><div class="line"> &lt;/form&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line"></div><div class="line">&lt;!--JS部分--&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    var input = document.getElementById(&quot;img_input&quot;);</div><div class="line">    var result = document.getElementById(&quot;result&quot;);</div><div class="line">    var img_area = document.getElementById(&quot;img_area&quot;);</div><div class="line">    window.onload = function() &#123;</div><div class="line">//检测浏览器是否支持FileReader对象</div><div class="line">    if (typeof(FileReader) === &apos;undefined&apos;) &#123;</div><div class="line">        result.innerHTML = &quot;FileReader is not supported...&quot;;</div><div class="line">        input.setAttribute(&apos;disabled&apos;, &apos;disabled&apos;);</div><div class="line">    &#125; else &#123;</div><div class="line">        input.addEventListener(&apos;change&apos;, readFile, false);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">//借鉴地址:http://www.th7.cn/web/html-css/201407/48937.shtml</div><div class="line">function readFile() &#123;</div><div class="line">    var file = this.files[0];</div><div class="line">    if (!/image\/\w+/.test(file.type)) &#123;</div><div class="line">        alert(&quot;image only please.&quot;);</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    var reader = new FileReader();//读取用户上传的图片</div><div class="line">    reader.readAsDataURL(file);//readAsDataURL可以获取API异步读取文件数据另存为数据URL;将该URL绑定到img标签的src属性上，可以实现图片上传预览</div><div class="line">    reader.onload = function(e) &#123;</div><div class="line">        var img = new Image,</div><div class="line">            width = 640, //图像调整</div><div class="line">            quality = 0.7, //图片质量</div><div class="line">            canvas = document.createElement(&quot;canvas&quot;),</div><div class="line">            drawer = canvas.getContext(&quot;2d&quot;);</div><div class="line">            img.src = this.result;//这句不好理解</div><div class="line">            console.log(this.result);</div><div class="line">        img.onload = function() &#123;</div><div class="line">            canvas.width = width;</div><div class="line">            canvas.height = width * (img.height / img.width);</div><div class="line">            drawer.drawImage(img, 0, 0, canvas.width, canvas.height);//使用canvas drawInmage接口绘制canvas 2d中</div><div class="line">            img.src = canvas.toDataURL(&quot;image/jpeg&quot;, quality);//toDataUrl接口把图片转成base64编码字符串</div><div class="line">            console.log(img.src);</div><div class="line">            result.innerHTML = &apos;&lt;img src=&quot;&apos; + &quot;data:image/png;base64,&quot;+img.src + &apos;&quot; alt=&quot;&quot;/&gt;&apos;;</div><div class="line">            img_area.innerHTML = &apos;&lt;div class=&quot;sitetip&quot;&gt;preview：&lt;/div&gt;&lt;img src=&quot;&apos; + img.src + &apos;&quot; alt=&quot;&quot; id=&quot;generate&quot; value=&quot;generate&quot; /&gt;&lt;input type=&quot;hidden&quot; id=&quot;hide&quot; name=&quot;hide&quot; value=&quot;&apos;+ img.src+&apos;&quot; /&gt;&apos;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function replace()&#123;</div><div class="line">     document.getElementById(&apos;myForm&apos;).submit();</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;!--JS部分--&gt;</div></pre></td></tr></table></figure></p>
<p>view.html:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;show&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">恭喜你上传成功!&lt;br/&gt;</div><div class="line">图片预览:&lt;br/&gt;</div><div class="line">&lt;img src=&quot;__ROOT__/&#123;$path&#125;&quot;&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>php:<br>注意:这里使用的是thinkphp3.2.3，为啥用框架呢，方便开发<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">namespace Home\Controller;</div><div class="line">use Think\Controller;</div><div class="line"></div><div class="line">class IndexController extends Controller &#123;</div><div class="line">    public function index()&#123;</div><div class="line">        $this-&gt;display();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public function addChk()&#123;</div><div class="line">        $base_img =I(&apos;post.hide&apos;);</div><div class="line">//$base_img是获取到前端传递的src里面的值，也就是我们的数据流文件,哎：注意base64编码的头部部分</div><div class="line">          $base_img = str_replace(&apos;data:image/jpeg;base64,&apos;, &apos;&apos;, $base_img);</div><div class="line">//  设置文件路径和文件前缀名称</div><div class="line">        $path = &quot;./&quot;;</div><div class="line">        $prefix=&apos;nx_&apos;;</div><div class="line">        $output_file = $prefix.time().rand(100,999).&apos;.jpg&apos;;</div><div class="line">        $path = $path.$output_file;</div><div class="line">//这句代码前加上清除输出，防止文件写入错误</div><div class="line">     ob_clean();</div><div class="line">//创建将数据流文件写入我们创建的文件内容中</div><div class="line">        $ifp = fopen( $path, &quot;wb&quot; );</div><div class="line">        fwrite( $ifp, base64_decode( $base_img) );</div><div class="line">        $this-&gt;assign(&apos;path&apos;,$path);</div><div class="line">        $this-&gt;assign(&apos;filename&apos;,$output_file);</div><div class="line">        $this-&gt;display(&apos;show&apos;);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="HTML5的FileReader接口"><a href="#HTML5的FileReader接口" class="headerlink" title="HTML5的FileReader接口"></a>HTML5的FileReader接口</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader" target="_blank" rel="external">借鉴</a><br>FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。<br>当然那么多API我才不想多说，只要能看懂代码，其他有空再说。</p>
<h4 id="canvas-drawImage接口"><a href="#canvas-drawImage接口" class="headerlink" title="canvas drawImage接口"></a>canvas drawImage接口</h4><p><a href="http://www.w3school.com.cn/tags/canvas_drawimage.asp" target="_blank" rel="external">借鉴</a><br>drawImage() 方法在画布上绘制图像、画布或视频。<br>drawImage() 方法也能够绘制图像的某些部分，以及/或者增加或减少图像的尺寸。当然我还是不细说。</p>
<h4 id="toDataUrl接口转换base64编码"><a href="#toDataUrl接口转换base64编码" class="headerlink" title="toDataUrl接口转换base64编码"></a>toDataUrl接口转换base64编码</h4><p><a href="http://www.jianshu.com/p/17d7e5ddf10a" target="_blank" rel="external">借鉴</a><br>怎么理解呢？toDataUrl接口可以将图片转换成base64编码。也就是将图片转换成字符。</p>
<h4 id="PHP将base64编码转换成图片"><a href="#PHP将base64编码转换成图片" class="headerlink" title="PHP将base64编码转换成图片"></a>PHP将base64编码转换成图片</h4><p><a href="http://www.cnblogs.com/qqblog/p/6513880.html" target="_blank" rel="external">借鉴</a><br>PHP内置的base64_decode方法可以将base64编码转换成图片，这一特性很大程度上对我们图片进行上传有了很大帮助。</p>
<h4 id="个人注意的点点滴滴"><a href="#个人注意的点点滴滴" class="headerlink" title="个人注意的点点滴滴"></a>个人注意的点点滴滴</h4><p>就个人而言，需注意以下几点:</p>
<h5 id="上传文件大小限制"><a href="#上传文件大小限制" class="headerlink" title="上传文件大小限制"></a>上传文件大小限制</h5><p>PHP默认对上传文件有很多限制，比入上传的文件大小必须小于2M，当然我们可以进行一些设置的修改:<br>打开php.ini，首先找到<br><code>file_uploads = on;</code>是否允许通过HTTP上传文件的开关。默认为ON即是开<br><code>upload_tmp_dir;</code>文件上传至服务器上存储临时文件的地方，如果没指定就会用系统默认的临时文件夹<br><code>upload_max_filesize = 8m;</code>望文生意，即允许上传文件大小的最大值。默认为2M<br><code>post_max_size = 8m ;</code>指通过表单POST给PHP的所能接收的最大值，包括表单里的所有值。默认为8M<br>一般地，设置好上述四个参数后，上传&lt;=8M的文件是不成问题，在网络正常的情况下。<br>但如果要上传&gt;8M的大体积文件，只设置上述四项还一定能行的通。</p>
<p>进一步配置以下的参数<br><code>max_execution_time = 600;</code>每个PHP页面运行的最大时间值(秒)，默认30秒<br><code>max_input_time = 600 ;</code>每个PHP页面接收数据所需的最大时间，默认60秒<br><code>memory_limit = 8m ;</code>每个PHP页面所吃掉的最大内存，默认8M<br>把上述参数修改后，在网络所允许的正常情况下，就可以上传大体积文件了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">max_execution_time = 600</div><div class="line">max_input_time = 600</div><div class="line">memory_limit = 32m</div><div class="line">file_uploads = on</div><div class="line">upload_tmp_dir = /tmp</div><div class="line">upload_max_filesize = 32m</div><div class="line">post_max_size = 32m</div></pre></td></tr></table></figure></p>
<p>进行了这些设置后，上传大文件再也不用愁了。</p>
<h5 id="除去base64编码的默认头部"><a href="#除去base64编码的默认头部" class="headerlink" title="除去base64编码的默认头部"></a>除去base64编码的默认头部</h5><p>记得想保存图片的时候，记得除去base64编码里面的图片头部，当然还需要在意的是:细节很重要<br><code>data:image/jpeg;base64,</code>和<code>data:image/jpg;base64,</code>一个字母弄了多久，你自己知道就好了。无论如何，好好学习技术肯定没错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$base_img = str_replace(&apos;data:image/jpeg;base64,&apos;, &apos;&apos;, $base_img);</div></pre></td></tr></table></figure></p>
<p>结果:成效还是很明显的，将4747KB的图片压缩成了114KB，大大减少了对服务器端上传的压力。<br><strong>以上就是对图片压缩的小小见解。当然得知公司还是人才不少的。</strong></p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常用DOS命令]]></title>
      <url>/%E5%B8%B8%E7%94%A8DOS%E5%91%BD%E4%BB%A4.html/</url>
      <content type="html"><![CDATA[<p>就个人而言，DOS是我所一直喜欢的，至始至终。但是没有系统化、专业化的学习也许终究是可悲的。<br><a id="more"></a><br>很多DOS命令是学习黑客技术的基础，也就是说掌握这些基础知识是必不可少的。<br>也许对于下面的命令我是该好好了解下了:</p>
<ul>
<li>net命令</li>
<li>远程登录telent命令</li>
<li>文件传输ftp命令</li>
<li>添加计划任务at命令(从win8起已经废除)改schtasks命令</li>
<li>查看修改文件夹权限cacls命令</li>
<li>回显echo命令</li>
<li>命令行下的注册表操作</li>
<li>查看当前系统用户情况query命令</li>
<li>终止会话logoff命令</li>
<li>物理网络查看ping命令</li>
<li>网络配置查询ipconfig命令</li>
<li>查看通信路由tracert命令</li>
<li>DNS查看nslook up(不是内部或外部命令)</li>
<li>地址解析arp命令</li>
<li>诊断nbtstat命令</li>
<li>netstat命令</li>
<li>route命令</li>
</ul>
<h3 id="命令解析"><a href="#命令解析" class="headerlink" title="命令解析"></a>命令解析</h3><p>谁叫我也不太了解呢，只能一个个用来学习了。</p>
<h4 id="net命令"><a href="#net命令" class="headerlink" title="net命令"></a>net命令</h4><p>net命令被称为功能强大的以命令行方式执行的感觉，它包含了管理网络环境、服务、用户、登录等windows 98/NT/2000中大部分重要的管理功能。</p>
<p>使用它可以管理本地或者远程计算机的网络环境，以及各种服务程序的运行和配置。或者进行用户管理和登陆管理等。</p>
<h5 id="net-view和net-use"><a href="#net-view和net-use" class="headerlink" title="net view和net use"></a>net view和net use</h5><p>其中最常用的是<code>net view</code>和<code>net use</code>，通过这两个命令，可以连接网络上开发了远程共享的系统，并且获得资料，这种远程共享本来是为便捷操作设计，但是很多网络管理员忽略了它的安全性，所有造成了很多不应该共享的信息的暴露，可以让入侵者轻易地获得计算机的隐私资料，具体的命令如下:<br>建立IPC空连接:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">net use \\ip地址 &quot;&quot; /user:&quot;&quot;</div></pre></td></tr></table></figure></p>
<p>建立IPC连接:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">net use \\192.168.0.1\\ipc$ &quot;12345&quot; /user:admin</div></pre></td></tr></table></figure></p>
<p>(假设IP为192.168.0.1,密码12345,用户名admin)<br>删除IPC连接:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">net use \\192.168.0.1\ipc$\del</div></pre></td></tr></table></figure></p>
<p>当然对于这两个命令需要深入研究:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">net view \\ip           //查看开了那些共享</div><div class="line">net view x: \\ip\sharp  //把共享映射为本地X盘</div></pre></td></tr></table></figure></p>
<h5 id="启动和关闭服务"><a href="#启动和关闭服务" class="headerlink" title="启动和关闭服务"></a>启动和关闭服务</h5><p>服务我就不多说了。<br>启动服务:<code>net start 服务名</code><br>关闭服务:<code>net stop 服务名</code></p>
<h5 id="启动和关闭共享"><a href="#启动和关闭共享" class="headerlink" title="启动和关闭共享"></a>启动和关闭共享</h5><p>计算机内部的共享资源的操作<br>启动共享:<code>net share 共享名</code><br>关闭共享:<code>net share 共享名/del</code><br>查看共享:<code>net share</code></p>
<h5 id="映射磁盘和删除映射磁盘"><a href="#映射磁盘和删除映射磁盘" class="headerlink" title="映射磁盘和删除映射磁盘"></a>映射磁盘和删除映射磁盘</h5><p>映射磁盘就是将其他的计算机盘符映射到本地磁盘<br>映射磁盘:<code>net use z:\192.168.0.1\c$</code><br>将受害者系统开放的默认共享C盘映射为自己的本地磁盘z，操作自己的z盘就想操作它的c盘。<br>注意:建立磁盘映射必须先建立IPC连接，要映射成的磁盘必须是本地不存在的盘符。<br>删除映射:<code>net use z:/del</code></p>
<h5 id="查看远程系统的时间"><a href="#查看远程系统的时间" class="headerlink" title="查看远程系统的时间"></a>查看远程系统的时间</h5><p><code>net time\IP</code></p>
<h5 id="添加和删除用户"><a href="#添加和删除用户" class="headerlink" title="添加和删除用户"></a>添加和删除用户</h5><p>查看用户:<code>net user</code><br>添加用户:<code>net user 用户名 密码 /add</code><br>删除用户:<code>net user 用户名 /del</code></p>
<h5 id="添加和删除到管理员组"><a href="#添加和删除到管理员组" class="headerlink" title="添加和删除到管理员组"></a>添加和删除到管理员组</h5><p>添加用户:<code>net localgroup administrators 用户名 /add</code><br>删除用户:<code>net localgroup administrators 用户名 /del</code></p>
<h5 id="激活和禁止guest账号"><a href="#激活和禁止guest账号" class="headerlink" title="激活和禁止guest账号"></a>激活和禁止guest账号</h5><p>激活guest:<code>net user guest /active:yes</code><br>禁止guest:<code>net user guest /del</code></p>
<h4 id="远程登录telnet命令"><a href="#远程登录telnet命令" class="headerlink" title="远程登录telnet命令"></a>远程登录telnet命令</h4><p>这个命令是用来远程连接的，但是默认为关闭需要打开。<br>格式:telnet IP port<br>telnet 192.168.0.1 1234<br>连接到192.168.0.1的1234端口，telnet的默认端口是23<br>条件:受害者开启<code>23</code>端口并且不使用<code>NTLM</code>验证。</p>
<h4 id="文件传输ftp命令"><a href="#文件传输ftp命令" class="headerlink" title="文件传输ftp命令"></a>文件传输ftp命令</h4><p>ftp进行文件的传输。<br>该命令最基本的是<code>ftp IP</code><br>在输入用户名和密码之后就可以使用get或者put来进行下载和上传操作。<br>使用disconnect断开连接，bye或者quit退出FTP。</p>
<h4 id="添加计划任务at命令-从win8起已经废除-改schtasks命令"><a href="#添加计划任务at命令-从win8起已经废除-改schtasks命令" class="headerlink" title="添加计划任务at命令(从win8起已经废除)改schtasks命令"></a>添加计划任务at命令(从win8起已经废除)改schtasks命令</h4><p>注:这些命令都不完善，在此我只是提供关键字，更多操作需要时google即可。<br>安排命令和程序定期运行或在指定时间内运行。从计划表中添加和删除任务，按需要启动和停止任务，显示和更改计划任务。</p>
<h5 id="创建新的计划任务"><a href="#创建新的计划任务" class="headerlink" title="创建新的计划任务"></a>创建新的计划任务</h5><p><code>schtasks /create</code></p>
<h5 id="删除计划任务"><a href="#删除计划任务" class="headerlink" title="删除计划任务"></a>删除计划任务</h5><p><code>schtasks  /Delete</code>         </p>
<h5 id="显示所有计划任务。"><a href="#显示所有计划任务。" class="headerlink" title="显示所有计划任务。"></a>显示所有计划任务。</h5><p><code>schtasks    /Query</code>    </p>
<h5 id="更改计划任务属性。"><a href="#更改计划任务属性。" class="headerlink" title="更改计划任务属性。"></a>更改计划任务属性。</h5><p><code>schtasks    /Change</code>   </p>
<h5 id="按需运行计划任务。"><a href="#按需运行计划任务。" class="headerlink" title="按需运行计划任务。"></a>按需运行计划任务。</h5><p><code>schtasks    /Run</code>   </p>
<h5 id="中止当前正在运行的计划任务。"><a href="#中止当前正在运行的计划任务。" class="headerlink" title="中止当前正在运行的计划任务。"></a>中止当前正在运行的计划任务。</h5><p><code>schtasks   /End</code></p>
<h5 id="显示与计划的任务名称相应的安全标识符。"><a href="#显示与计划的任务名称相应的安全标识符。" class="headerlink" title="显示与计划的任务名称相应的安全标识符。"></a>显示与计划的任务名称相应的安全标识符。</h5><p><code>schtasks    /ShowSid</code>       </p>
<h4 id="查看修改文件夹权限cacls命令"><a href="#查看修改文件夹权限cacls命令" class="headerlink" title="查看修改文件夹权限cacls命令"></a>查看修改文件夹权限cacls命令</h4><p>注意:不推荐使用 Cacls，请使用 Icacls</p>
<h4 id="回显echo命令"><a href="#回显echo命令" class="headerlink" title="回显echo命令"></a>回显echo命令</h4><p>也就是输出命令<br><code>echo “输出内容”</code></p>
<h4 id="命令行下的注册表操作"><a href="#命令行下的注册表操作" class="headerlink" title="命令行下的注册表操作"></a>命令行下的注册表操作</h4><h4 id="查看当前系统用户情况query命令"><a href="#查看当前系统用户情况query命令" class="headerlink" title="查看当前系统用户情况query命令"></a>查看当前系统用户情况query命令</h4><p>使用<code>query user</code>可以查看当前系统的会话，比如查看是否有人使用远程终端登录服务器<br>使用<code>query</code>可以查看到某用户的<code>session</code>，然后通过<code>logoff</code>命令将其踢出去。</p>
<h4 id="终止会话logoff命令"><a href="#终止会话logoff命令" class="headerlink" title="终止会话logoff命令"></a>终止会话logoff命令</h4><p>logoff用法help即可，然后通过<code>logoff</code>命令将其它管理员和用户踢出去。</p>
<h4 id="物理网络查看ping命令"><a href="#物理网络查看ping命令" class="headerlink" title="物理网络查看ping命令"></a>物理网络查看ping命令</h4><p>命令ping我觉得最大的用处就是看远程计算机IP是否可以正常访问吧!<br>ping命令可以检测数据包在哪一个节点之后出现了问题，也可以判断对方是windows系统还是linux系统。(不过并不太可靠)<br>还是可以得到目的网站的IP地址。</p>
<h4 id="网络配置查询ipconfig命令"><a href="#网络配置查询ipconfig命令" class="headerlink" title="网络配置查询ipconfig命令"></a>网络配置查询ipconfig命令</h4><p>使用ipconfig/all命令可以方便地查看网卡的MAC地址、主机的网络设置等，在向内网渗透的过程中，需要了解受害者的网络配置，可以使用ipconfig来查看。</p>
<h4 id="查看通信路由tracert命令"><a href="#查看通信路由tracert命令" class="headerlink" title="查看通信路由tracert命令"></a>查看通信路由tracert命令</h4><p>tracert是路由跟踪程序，用于确定IP数据报访问目标所经过的路径。<br>具体功暂时我也不太清楚理解，以后补充！</p>
<h4 id="DNS查看nslookup命令"><a href="#DNS查看nslookup命令" class="headerlink" title="DNS查看nslookup命令"></a>DNS查看nslookup命令</h4><p>使用nslookup可以查看主机的DNS服务器，nslookup最简单的用户用法就是查询域名。</p>
<h4 id="地址解析arp命令"><a href="#地址解析arp命令" class="headerlink" title="地址解析arp命令"></a>地址解析arp命令</h4><p>用于显示和修改地址解析协议缓存表的内容，缓存表项是IP地址与网卡地址对。</p>
<h4 id="诊断nbtstat命令"><a href="#诊断nbtstat命令" class="headerlink" title="诊断nbtstat命令"></a>诊断nbtstat命令</h4><p>显示协议统计和当前使用 NBI 的 TCP/IP 连接，包括本地计算机和远程计算机的NetBIOS名称表，以及NetBIOS名字缓存。</p>
<h4 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h4><p>显示TCP连接、计算机正在监听的端口、以太网统计信息、IP路由表、IPv4统计信息(包括IP、ICMP、TCP和UDP)和IPv6统计信息(包括IPv6、ICMPv6、TCP over IPv6和UDP over IPv6)等协议。</p>
<h4 id="route命令"><a href="#route命令" class="headerlink" title="route命令"></a>route命令</h4><p>显示和修改本地的路由表。</p>
<p><strong>以上就是对常用DOS命令的小小见解。</strong></p>
]]></content>
      
        <categories>
            
            <category> 网络攻防 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[菜鸟使用树莓派进行简易人脸识别(二)]]></title>
      <url>/%E8%8F%9C%E9%B8%9F%E4%BD%BF%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E8%BF%9B%E8%A1%8C%E7%AE%80%E6%98%93%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB(%E4%BA%8C).html/</url>
      <content type="html"><![CDATA[<p>学习了Demo里面的基础知识后，看样子是需要真正来理解Python项目中的代码了。<br><a id="more"></a><br><a href="http://blog.csdn.net/jireren/article/details/52167791" target="_blank" rel="external">代码Demo参考</a><br>当然这只是一个理解代码的文章。所以贴出代码吧!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">### 导入库 ###</div><div class="line"></div><div class="line">from picamera.array import PiRGBArray</div><div class="line">from picamera import PiCamera</div><div class="line">import time</div><div class="line">import cv2</div><div class="line">import os</div><div class="line"></div><div class="line"></div><div class="line">### 安装程序 ###</div><div class="line"></div><div class="line"># 中心坐标</div><div class="line">cx = 160</div><div class="line">cy = 120</div><div class="line"></div><div class="line">os.system( &quot;echo 0=150 &gt; /dev/servoblaster&quot; )</div><div class="line">os.system( &quot;echo 1=150 &gt; /dev/servoblaster&quot; )</div><div class="line"></div><div class="line">xdeg = 150</div><div class="line">ydeg = 150</div><div class="line"></div><div class="line"># 设置相机</div><div class="line">camera = PiCamera()</div><div class="line">camera.resolution = ( 320, 240 )</div><div class="line">camera.framerate = 60</div><div class="line">rawCapture = PiRGBArray( camera, size=( 320, 240 ) )</div><div class="line"></div><div class="line"># 加载一个级联文件，用于检测人脸</div><div class="line">face_cascade = cv2.CascadeClassifier( &apos;/home/pi/opencv-2.4.9/data/lbpcascades/lbpcascade_frontalface.xml&apos; ) </div><div class="line"></div><div class="line">t_start = time.time()</div><div class="line">fps = 0</div><div class="line"></div><div class="line"></div><div class="line">### 主函数 ###</div><div class="line"></div><div class="line"># 从相机捕捉帧</div><div class="line">for frame in camera.capture_continuous( rawCapture, format=&quot;bgr&quot;, use_video_port=True ):</div><div class="line"></div><div class="line">    image = frame.array</div><div class="line"></div><div class="line">    # 使用我们加载的级联文件来检测人脸 </div><div class="line">    gray = cv2.cvtColor( image, cv2.COLOR_BGR2GRAY )</div><div class="line">    faces = face_cascade.detectMultiScale( gray )</div><div class="line"></div><div class="line">    print &quot;Found &quot; + str( len( faces ) ) + &quot; face(s)&quot;</div><div class="line"></div><div class="line">    # 画一个矩形在每一个脸和移动电机面对</div><div class="line">    for ( x, y, w, h ) in faces:</div><div class="line"></div><div class="line">        cv2.rectangle( image, ( x, y ), ( x + w, y + h ), ( 100, 255, 100 ), 2 )</div><div class="line">        cv2.putText( image, &quot;Face No.&quot; + str( len( faces ) ), ( x, y ), cv2.FONT_HERSHEY_SIMPLEX, 0.5, ( 0, 0, 255 ), 2 )</div><div class="line"></div><div class="line">        tx = x + w/2</div><div class="line">        ty = y + h/2</div><div class="line"></div><div class="line">        if   ( cx - tx &gt;  10 and xdeg &lt;= 190 ):</div><div class="line">            xdeg += 3</div><div class="line">            os.system( &quot;echo 0=&quot; + str( xdeg ) + &quot; &gt; /dev/servoblaster&quot; )</div><div class="line">        elif ( cx - tx &lt; -10 and xdeg &gt;= 110 ):</div><div class="line">            xdeg -= 3</div><div class="line">            os.system( &quot;echo 0=&quot; + str( xdeg ) + &quot; &gt; /dev/servoblaster&quot; )</div><div class="line"></div><div class="line">        if   ( cy - ty &gt;  10 and ydeg &gt;= 110 ):</div><div class="line">            ydeg -= 3</div><div class="line">            os.system( &quot;echo 1=&quot; + str( ydeg ) + &quot; &gt; /dev/servoblaster&quot; )</div><div class="line">        elif ( cy - ty &lt; -10 and ydeg &lt;= 190 ):</div><div class="line">            ydeg += 3</div><div class="line">            os.system( &quot;echo 1=&quot; + str( ydeg ) + &quot; &gt; /dev/servoblaster&quot; )</div><div class="line"></div><div class="line">    # 计算并显示FPS</div><div class="line">    fps = fps + 1</div><div class="line">    sfps = fps / ( time.time() - t_start )</div><div class="line">    cv2.putText( image, &quot;FPS : &quot; + str( int( sfps ) ), ( 10, 10 ), cv2.FONT_HERSHEY_SIMPLEX, 0.5, ( 0, 0, 255 ), 2 )    </div><div class="line"></div><div class="line">    # 展示框架</div><div class="line">    cv2.imshow( &quot;Frame&quot;, image )</div><div class="line">    cv2.waitKey( 1 )</div><div class="line"></div><div class="line">    # 在准备下一帧时清除流</div><div class="line">    rawCapture.truncate( 0 )</div></pre></td></tr></table></figure></p>
<p>这是原代码，只不过我将注释换成了中文了，方便阅读吧。<br>现在我需要做的就是理解没一行代码，就是这样无奈~~~~</p>
<p><strong>以上就是对人脸识别的小小见解。</strong></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[菜鸟使用树莓派进行简易人脸识别(一)]]></title>
      <url>/%E8%8F%9C%E9%B8%9F%E4%BD%BF%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E8%BF%9B%E8%A1%8C%E7%AE%80%E6%98%93%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB(%E4%B8%80).html/</url>
      <content type="html"><![CDATA[<p>机缘巧合下参与了人工智能工作室项目”树莓派进行人脸识别”，因此可以好好研究一下Python了。<br><a id="more"></a><br>对于Python，只能既爱又恨了。爱的是Python的强大，恨的是可惜看了几本书没能学好Python的开发。原因也是有的，不敲代码看书就是没毛用。<br>不过这次”树莓派进行人脸识别”项目负责软件代码方面，所以必须认真理解代码学习Python。<br><a href="http://blog.csdn.net/jireren/article/details/52167791" target="_blank" rel="external">代码Demo参考</a><br>当然第一次接触这个Demo并没有认真理解清楚，所以我进行了以下的工作:</p>
<ul>
<li>介绍树莓派</li>
<li>手把手教你如何用 OpenCV + Python 实现人脸识别</li>
<li>Python OS模块常用功能中文图文详解</li>
<li>Python time模块学习</li>
<li>Python模块picamera</li>
</ul>
<h4 id="介绍树莓派"><a href="#介绍树莓派" class="headerlink" title="介绍树莓派"></a>介绍树莓派</h4><p><a href="http://baike.baidu.com/link?url=1WYrsq-uzPIqoXV6iZdRRLFdj-uLNZve6RJycGpVOM8pj6wbjaT6qkhRH1ZPMDB80il5YbXR4WruUZZJuOQkO_8U1t9AIeTnO823KkIK6fxAPPIY4c3dqMWgwpw06_PB" target="_blank" rel="external">借鉴</a><br>树莓派是一个职业信用卡大小的裸露电路板，它也是一个运行linux操作系统的完全可编程的PC系统。<br>当然在此，我们可以了解到可以完成大部分电脑能完成的事情:<code>编辑office文档</code>、<code>浏览网页</code>、<code>玩游戏</code>。<br>当然设置它的配件:<code>SD卡(预装系统)</code>、<code>USB键盘和鼠标</code>、<code>显示器</code>、<code>WiFi适配器(USB无线网卡)</code>…..其他就不说了，对硬件不感冒。<br>当然安装操作系统<br>准备工作和安装实战百科说的比较好哦！可以借鉴其他的。<br>启动成功的景象:</p>
<p><img src="/菜鸟使用树莓派进行简易人脸识别(一).html/5d6034a85edf8db125dae65c0823dd54564e7416.jpg" alt="启动图片"><br>不要说对树莓派没什么了解，说实话，在写这篇博客之前我也从未接触过它，不过并不担心我们对它的了解。</p>
<h5 id="手把手教你如何用-OpenCV-Python-实现人脸识别"><a href="#手把手教你如何用-OpenCV-Python-实现人脸识别" class="headerlink" title="手把手教你如何用 OpenCV + Python 实现人脸识别"></a>手把手教你如何用 OpenCV + Python 实现人脸识别</h5><p><a href="http://www.leiphone.com/news/201704/rYdpAvh4SvgVPpRQ.html" target="_blank" rel="external">借鉴</a><br>这篇文章理解还是较简单的。无非三步:</p>
<ul>
<li>OpenCV的Python环境搭建</li>
<li>相关知识储备</li>
<li>代码的实现人脸识别</li>
</ul>
<h5 id="OpenCV的Python环境搭建"><a href="#OpenCV的Python环境搭建" class="headerlink" title="OpenCV的Python环境搭建"></a>OpenCV的Python环境搭建</h5><p><a href="http://blog.csdn.net/marksinoberg/article/details/52442229" target="_blank" rel="external">借鉴</a><br>对于菜鸟的我来说，先了解<code>OpenCV</code>要紧，没办法<code>百科</code>了个答案：<br>大概意思就是OpenCv是一个跨平台计算机视觉库。用C++编写实现的一些功能的。<br>笼统的说吧就是它可以进行<code>图像处理</code>和<code>视觉</code>操作，也就是让计算机有部分<code>视觉功能</code>吧!<br>当然今天我们主要使用<code>Python</code>来使用它。<br>首先只能安装OpenCV了，只能使用<code>pip</code>,什么还没安装，我也没有哦，看<a href="http://blog.csdn.net/u010128736/article/details/52713204" target="_blank" rel="external">借鉴</a>吧。</p>
<h5 id="相关知识储备"><a href="#相关知识储备" class="headerlink" title="相关知识储备"></a>相关知识储备</h5><p>Haar特征值反映了图像的灰度变化情况。<br>例如：脸部的一些特征能由矩形特征简单的描述，如：眼睛要比脸颊颜色要深，鼻梁两侧比鼻梁颜色要深，嘴巴比周围颜色要深等。<br><code>opencv api</code><br>要想使用opencv，就必须先知道其能干什么，怎么做。于是API的重要性便体现出来了。就本例而言，使用到的函数很少，也就普通的读取图片，灰度转换，显示图像，简单的编辑图像罢了。<br><code>读取图片</code><br>只需要给出待操作的图片的路径即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">image = cv2.imread(imagepath)</div></pre></td></tr></table></figure></p>
<p><code>灰度转换</code><br>灰度转换的作用就是：转换成灰度的图片的计算强度得以降低。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">gray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)</div></pre></td></tr></table></figure></p>
<p><code>画图</code><br>opencv 的强大之处的一个体现就是其可以对图片进行任意编辑，处理。 下面的这个函数最后一个参数指定的就是画笔的大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">cv2.rectangle(image,(x,y),(x+w,y+w),(0,255,0),2)</div></pre></td></tr></table></figure></p>
<p><code>显示图像</code><br>编辑完的图像要么直接的被显示出来，要么就保存到物理的存储介质。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">cv2.imshow(&quot;Image Title&quot;,image)</div></pre></td></tr></table></figure></p>
<p><code>获取人脸识别训练数据</code><br>看似复杂，其实就是对于人脸特征的一些描述，这样opencv在读取完数据后很据训练中的样品数据，就可以感知读取到的图片上的特征，进而对图片进行人脸识别。<br>这里卖弄的这个xml文件，就是opencv在GitHub上共享出来的具有普适的训练好的数据。我们可以直接的拿来使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">face_cascade = cv2.CascadeClassifier(r&apos;./haarcascade_frontalface_default.xml&apos;)</div></pre></td></tr></table></figure></p>
<p><code>探测人脸</code><br>说白了，就是根据训练的数据来对新图片进行识别的过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line"># 探测图片中的人脸</div><div class="line">faces = face_cascade.detectMultiScale(</div><div class="line">    gray,</div><div class="line">    scaleFactor = 1.15,</div><div class="line">    minNeighbors = 5,</div><div class="line">    minSize = (5,5),</div><div class="line">    flags = cv2.cv.CV_HAAR_SCALE_IMAGE</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>我们可以随意的指定里面参数的值，来达到不同精度下的识别。返回值就是opencv对图片的探测结果的体现。</p>
<p><code>处理人脸探测的结果</code><br>结束了刚才的人脸探测，我们就可以拿到返回值来做进一步的处理了。但这也不是说会多么的复杂，无非添加点特征值罢了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import cv2</div><div class="line">print &quot;发现&#123;0&#125;个人脸!&quot;.format(len(faces))</div><div class="line">for(x,y,w,h) in faces:</div><div class="line">   cv2.rectangle(image,(x,y),(x+w,y+w),(0,255,0),2)</div></pre></td></tr></table></figure></p>
<h5 id="代码的实现人脸识别"><a href="#代码的实现人脸识别" class="headerlink" title="代码的实现人脸识别"></a>代码的实现人脸识别</h5><p><img src="http://static.leiphone.com/uploads/new/article/740_740/201704/5903040bf4146.jpg?imageMogr2/format/jpg/quality/90" alt="图片素材"></p>
<p>具体代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"># coding:utf-8</div><div class="line">import sys</div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(&apos;utf8&apos;)</div><div class="line">import cv2</div><div class="line"># 待检测的图片路径</div><div class="line">imagepath = r&apos;./heat.jpg&apos;</div><div class="line"># 获取训练好的人脸的参数数据，这里直接从GitHub上使用默认值</div><div class="line">face_cascade = cv2.CascadeClassifier(r&apos;./haarcascade_frontalface_default.xml&apos;)</div><div class="line"># 读取图片</div><div class="line">image = cv2.imread(imagepath)</div><div class="line">gray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)</div><div class="line"># 探测图片中的人脸</div><div class="line">faces = face_cascade.detectMultiScale(</div><div class="line">    gray,</div><div class="line">    scaleFactor = 1.15,</div><div class="line">    minNeighbors = 5,</div><div class="line">    minSize = (5,5),</div><div class="line">    flags = cv2.cv.CV_HAAR_SCALE_IMAGE</div><div class="line">)</div><div class="line">print &quot;发现&#123;0&#125;个人脸!&quot;.format(len(faces))</div><div class="line">for(x,y,w,h) in faces:</div><div class="line">    # cv2.rectangle(image,(x,y),(x+w,y+w),(0,255,0),2)</div><div class="line">    cv2.circle(image,((x+x+w)/2,(y+y+h)/2),w/2,(0,255,0),2)</div><div class="line">cv2.imshow(&quot;Find Faces!&quot;,image)</div><div class="line">cv2.waitKey(0)</div></pre></td></tr></table></figure></p>
<p>输出结果:<br><img src="https://static.leiphone.com/uploads/new/article/740_740/201704/5903046d63e12.jpg?imageMogr2/format/jpg/quality/90" alt="输出结果"></p>
<p>代码理解:<br>就个人而言，上述代码在我的<code>IDE</code>里面运行时绝对有错误的。<br>不过嘛，有幸我还是完成的这个小小案例。<br>所有先贴上自己代码，然后就不用理解了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"># coding:utf-8</div><div class="line">import sys</div><div class="line">#reload(sys)</div><div class="line">#sys.setdefaultencoding(&apos;utf8&apos;)</div><div class="line">type = sys.getfilesystemencoding() #处理字符编码进行修改</div><div class="line"></div><div class="line">import cv2</div><div class="line">imagepath = r&apos;./1.jpg&apos;# 待检测的图片路径</div><div class="line"></div><div class="line"># 获取训练好的人脸的参数数据，这里直接从GitHub上使用默认值</div><div class="line">face_cascade = cv2.CascadeClassifier(r&apos;./haarcascade_frontalface_default.xml&apos;)</div><div class="line"></div><div class="line"># 读取图片</div><div class="line">image = cv2.imread(imagepath) </div><div class="line">gray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)#灰化</div><div class="line"></div><div class="line"></div><div class="line">###探测图片中的人脸</div><div class="line">faces = face_cascade.detectMultiScale(</div><div class="line">    gray,#进行检测的图像，这里是转换后的</div><div class="line">    scaleFactor = 1.15,#距离相机不同的距离</div><div class="line">    minNeighbors = 5,#对检测点周边多少有效点</div><div class="line">    minSize = (5,5),#检测点的最小值，或者说就是检测点的最终值</div><div class="line">   #这个参数在新版的opencv是不需要的,暂时不管了,注释掉同样可以 </div><div class="line">   #flags = cv2.cv.CV_HAAR_SCALE_IMAGE#相反不1注释却有错</div><div class="line">)</div><div class="line">#设置参数，达到识别。返回值就是opencv对图片的探测结果的体现。</div><div class="line">print &quot;发现&#123;0&#125;个人脸！&quot;.decode(&apos;utf-8&apos;).encode(type).format(len(faces)) #记住人脸的数量</div><div class="line"></div><div class="line">for(x,y,w,h) in faces:</div><div class="line">    cv2.circle(image,((x+x+w)/2,(y+y+h)/2),w/2,(0,255,0),2)</div><div class="line">    #循环对人脸图片进行描绘</div><div class="line">  </div><div class="line">######个人测试数据</div><div class="line">#x = 150</div><div class="line">#y = 150</div><div class="line">#w = 150</div><div class="line">#######个人测试数据</div><div class="line">#cv2.rectangle(image,(x,y),(x+w,y+w),(0,255,0),2)# </div><div class="line">#######个人测试数据</div><div class="line"></div><div class="line"></div><div class="line">cv2.imshow(&quot;find image&quot;,image)#展现图片</div><div class="line">cv2.waitKey(0)#waitKey(0)表示这一帧在你按下任意键前始终显示</div></pre></td></tr></table></figure></p>
<p>没办法个人代码就是这样，应该可以理解了。<br>查看可<a href="https://my.oschina.net/chinesezhx/blog/520917" target="_blank" rel="external">借鉴</a></p>
<h4 id="Python-OS模块常用功能中文图文详解"><a href="#Python-OS模块常用功能中文图文详解" class="headerlink" title="Python OS模块常用功能中文图文详解"></a>Python OS模块常用功能中文图文详解</h4><p><a href="http://www.iplaypy.com/module/os.html" target="_blank" rel="external">借鉴</a><br> OS模块在我的理解中他就类似于其他语言的文件处理模块吧，无非一些函数接口让你可以操作文件和目录，是不是很酷。<br> 对于os我先不多介绍，只说明程序中需要理解的代码和基础模块而已。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import os #导入os模块</div><div class="line">print os.getcwd()  #获取当前路径</div><div class="line">print os.listdir(&apos;/home/wwwroot&apos;) #列出目录下所有文件和文件夹</div><div class="line">print os.mkdir(&apos;heihei&apos;) #创建一个heihei的目录</div><div class="line">print os.rmdir(&apos;abc&apos;) #删除一个abc目录</div><div class="line">print os.rename(&apos;abc.txt&apos;,&apos;readme.txt&apos;) #重命名一个文件</div></pre></td></tr></table></figure></p>
<p>话说和linux命令查这么像呢，不管了。</p>
<h4 id="Python-time模块学习"><a href="#Python-time模块学习" class="headerlink" title="Python time模块学习"></a>Python time模块学习</h4><p><a href="http://python.jobbole.com/85491/" target="_blank" rel="external">借鉴</a><br>time模块是用于管理时间和日期的C库函数，这是因为它绑定到底层C实现，所有一些细节会基于具体的平台而不同。<br>说时间对于语言的时间我觉得就是烦，所有还是粗略了解。</p>
<ul>
<li><p>time()<br>返回纪元开始的秒数，返回为浮点数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;import time</div><div class="line">&gt;&gt;&gt;time.time()</div><div class="line">1495020286.013</div></pre></td></tr></table></figure>
</li>
<li><p>ctime()<br>返回友好的人类时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;import time</div><div class="line">&gt;&gt;&gt;time.ctime()</div><div class="line">&apos;Wed May 17 19:27:21 2017&apos;</div></pre></td></tr></table></figure>
</li>
<li><p>struct_time()<br>用这个可以分开存储时间的各个部分，感觉对我可爱极了。<br>gmtime()用于获取UTC(格林尼治)时间，localtime()用于获取当前时区的当前时间。</p>
</li>
<li>sleep()<br>说实话，这个就相当于定时器，规定间隔多长时间在运行下面代码。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import time</div><div class="line">time.sleep(5)</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Python模块picamera"><a href="#Python模块picamera" class="headerlink" title="Python模块picamera"></a>Python模块picamera</h4><p><a href="https://my.oschina.net/surenpi/blog/605526" target="_blank" rel="external">借鉴</a><br>单独理解<code>picamera</code>我还真不知道是什么，也可能就仅仅是一个Python模块吧！而它是用来操作树莓派摄像头的。<br>它的更多<a href="http://picamera.readthedocs.org/en/release-1.2/api.html" target="_blank" rel="external">API介绍</a><br>当然在此我还是不去深究那强悍的API介绍了。</p>
<hr>
<p>需修改</p>
<p><code>最简单的拍照</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[codesyntax lang=&quot;python&quot;]</div><div class="line"></div><div class="line">!/usr/bin/python</div><div class="line"># from http://surenpi.com</div><div class="line"># raspberry camera python example</div><div class="line"></div><div class="line">import picamera</div><div class="line">import time</div><div class="line"></div><div class="line">cam = picamera.PiCamera()</div><div class="line">cam.vflip = True</div><div class="line">cam.capture(&apos;a.jpg&apos;)</div><div class="line">cam.close()</div><div class="line"></div><div class="line">print &apos;capture done.&apos;</div></pre></td></tr></table></figure></p>
<p>[/codesyntax]</p>
<p><code>录制视频</code></p>
<p>可以将视频保存到文件中或者其他地方，默认录制的时候是不会有预览的，可以通过调用start_preview函数来预览 [codesyntax lang=”python”]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import picamera</div><div class="line"></div><div class="line">with picamera.PiCamera() as camera:</div><div class="line">	camera.resolution = (640, 480)</div><div class="line">	camera.start_preview()</div><div class="line"></div><div class="line">	camera.start_recording(&apos;suren.h264&apos;, format=&apos;h264&apos;, quantization=23, resize=(1024, 768))</div><div class="line">	camera.wait_recording(60)</div><div class="line">	camera.stop_recording()</div><div class="line"></div><div class="line">	camera.stop_preview()</div></pre></td></tr></table></figure></p>
<p>[/codesyntax] start_recording(output, format=None, resize=None, **options) start_recording的参数只是一个字符串的话，会被当作是文件名；如果是个对象的话，会回调这个实例对象的write方法 录制的文件格式默认为h264。wait_recording函数规定了录制的时长。 要想关闭红灯显示的话，可以设置camera.led = False。</p>
<p><strong>以上就是对人脸识别的小小见解。</strong></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> 人工智能 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[web网站从linux移植到windows server 2008]]></title>
      <url>/web%E7%BD%91%E7%AB%99%E4%BB%8Elinux%E7%A7%BB%E6%A4%8D%E5%88%B0windows%20server%202008.html/</url>
      <content type="html"><![CDATA[<p>其实对于web服务器配置并没有多难，但是比较繁琐，很多问题需要经验，所有记之。<br><a id="more"></a><br>最终项目还是从空间到centos选择了windows 的怀抱，原因很简单，蛋疼的空间不是尔等凡夫俗子所能够征服的。linux也不是一天能够玩转的。<br>对于网站的移植无非做几件事:</p>
<ul>
<li>搭建windows server 2008服务器PHP运行环境</li>
<li>备份linux下的web程序源码和数据库数据</li>
<li>导入web程序源码和数据库配置</li>
<li>设置域名解析</li>
</ul>
<h4 id="搭建windows-server-2008服务器PHP运行环境"><a href="#搭建windows-server-2008服务器PHP运行环境" class="headerlink" title="搭建windows server 2008服务器PHP运行环境"></a>搭建windows server 2008服务器PHP运行环境</h4><p>Windows下面的IIS加phpStudy就是简单，呵呵。<br><a href="http://www.jb51.net/article/49865.htm" target="_blank" rel="external">借鉴</a><br>当然对于上面的网址我有以下几点补充:</p>
<ul>
<li>IIS配置时”应用程序开发”最好全选</li>
<li>更改IIS的默认文档设置</li>
<li>添加web程序文件夹权限为<code>everyone</code>，所有权限</li>
<li>phpStudy设置为管理员权限启动<br>在IIS里面添加网站内容，挺简单的操作。<h4 id="备份linux下的web程序源码和数据库数据"><a href="#备份linux下的web程序源码和数据库数据" class="headerlink" title="备份linux下的web程序源码和数据库数据"></a>备份linux下的web程序源码和数据库数据</h4><h5 id="备份linux下的web程序源码"><a href="#备份linux下的web程序源码" class="headerlink" title="备份linux下的web程序源码"></a>备份linux下的web程序源码</h5>备份web程序源码，首先使用<code>Xshell</code>远程连接工具连接远程服务器，然后压缩web网站程序，但是竟然告诉我不能运行zip压缩命令。<br>没办法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install zip unzip</div></pre></td></tr></table></figure>
</li>
</ul>
<p>然后成功安装zip命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">zip  -r kjl.zip  kjl</div></pre></td></tr></table></figure></p>
<p>然后就可以压缩web程序了。</p>
<p>对于web程序的下载我没有用linux命令，我使用了我喜欢的<code>FileZilla</code>服务器连接工具，嘿嘿，反正我觉得这个工具比较强大。<br>下载web程序的压缩包到本地。</p>
<h5 id="备份数据库数据"><a href="#备份数据库数据" class="headerlink" title="备份数据库数据"></a>备份数据库数据</h5><p>对于空间数据库的坑爹我已不想多说，幸好得到了<code>Navicat for MySQL</code>程序的眷恋，远程连接数据库备份数据库没问题而言。<br>登录后选中数据库，右键<code>转储SQL</code>即可，这样数据库备份就没有任何问题而言了。</p>
<h4 id="导入web程序源码和数据库配置"><a href="#导入web程序源码和数据库配置" class="headerlink" title="导入web程序源码和数据库配置"></a>导入web程序源码和数据库配置</h4><p>对于windows服务器，当然还是windows内部的<code>远程桌面连接</code>给力，通过与远程共享文件夹与本地进行数据的传输。<br>将web程序源码放到www网站目录里面即可。sql文件通过phpStudy里面的<code>MySQL-Front</code>先建立数据库，然后导入即可。需要注意的是文件所有编码必须保持一致吧！小编一致使用<code>utf8</code>。</p>
<h4 id="设置域名解析"><a href="#设置域名解析" class="headerlink" title="设置域名解析"></a>设置域名解析</h4><p>对于域名解析，当初二话不说上阿里云进行域名解析，谁知道它的域名来着<code>网易中国</code>，没办法，直接上网易中国进行域名解析。域名解析之前可能觉得高大上，但是解析多了才发现操作并没有想象中的那么简单。</p>
<h4 id="小小教训"><a href="#小小教训" class="headerlink" title="小小教训"></a>小小教训</h4><p>说实话，我真的不能够明白的是基于thinkcmf的二次开发网站时，所有东西布置完毕。但是为何就是不能显示正确呢？反而显示<code>404</code>，虽然表示无奈，但是打开<code>thinkphp</code>的调试模式,网站立即访问正确。<br>然后关闭调试模式，网站正确显示。</p>
<p><strong>以上就是我将web网站从linux移植到windows server 2008的整个过程了。</strong></p>
]]></content>
      
        <categories>
            
            <category> PHP </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> php </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mysql常用命令简介]]></title>
      <url>/mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B.html/</url>
      <content type="html"><![CDATA[<p>mysql是一个关系型数据库管理系统，由于其开源免费，在web开发方面占有重要地位。<br><a id="more"></a><br>今天我们所说的是mysql的命令行模式，不同于常规的视图操作界面。</p>
<h4 id="mysql服务相关"><a href="#mysql服务相关" class="headerlink" title="mysql服务相关"></a>mysql服务相关</h4><p>　　我们可以这样理解，mysql的正常运行离不开mysql服务的正常启动。所有对于这些我们必须掌握。</p>
<ul>
<li>启动mysql服务<br>可以使用命令:<ul>
<li>mysql脚本启动: <code>/etc/init.d/mysqld start</code></li>
<li>service服务启动:<code>service mysqld start</code></li>
<li>使用safe_mysqld启动:<code>safe_mysqld&amp;</code></li>
</ul>
</li>
<li>停止服务<ul>
<li>使用service停止:<code>service mysqld stop</code></li>
<li>使用mysqld脚本停止:<code>/etc/init.d/mysqld stop</code></li>
</ul>
</li>
<li>重启<ul>
<li>使用service重启:<code>service mysqld restart</code></li>
<li>使用mysqld脚本重启:<code>/etc/init.d/mysqld restart</code><br>备注:查看mysql端口是否已经使用，使用netstat -anp命令查询服务器端口使用情况。</li>
</ul>
</li>
</ul>
<h4 id="进入mysql"><a href="#进入mysql" class="headerlink" title="进入mysql"></a>进入mysql</h4><ul>
<li><p>连接本地(在安装目录下操作)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /mysql/bin#与具体安全目录有关</div><div class="line">mysql -u root -p #回车后输入密码</div><div class="line">mysql&gt; #成功后显示</div></pre></td></tr></table></figure>
</li>
<li><p>连接远程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -h 110.110.110.110 -u root -p 123;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注:其实各参数与数据可以不用加空格。</p>
<h4 id="退出mysql"><a href="#退出mysql" class="headerlink" title="退出mysql"></a>退出mysql</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">exit(回车)</div></pre></td></tr></table></figure>
<h4 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h4><ul>
<li>给root加个密码abcd1234<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysqladmin -u root -password abcd1234</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注:之前root没有密码，所有-p旧密码可以省略。</p>
<ul>
<li>修改root密码为1234abcd<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysqladmin -u root -p abcd1234 password 1234abcd</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="新增用户"><a href="#新增用户" class="headerlink" title="新增用户"></a>新增用户</h4><p>格式：grant select on 数据库.* to 用户名@登录主机 identified by “密码”<br>注：个人觉得有些繁琐，且大部分时间不会新增，特此google即可。</p>
<h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><p>命令:<code>create database &lt;数据库名&gt;</code></p>
<h4 id="显示数据库"><a href="#显示数据库" class="headerlink" title="显示数据库"></a>显示数据库</h4><p>命令：<code>show databases;</code></p>
<h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h4><p>命令:<code>drop database &lt;数据库名&gt;；</code></p>
<h4 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h4><p>命令:<code>use &lt;数据库名&gt;；<code></code></code></p>
<h4 id="显示数据表"><a href="#显示数据表" class="headerlink" title="显示数据表"></a>显示数据表</h4><p>命令:<code>show tables;</code></p>
<h4 id="增加数据记录"><a href="#增加数据记录" class="headerlink" title="增加数据记录"></a>增加数据记录</h4><p> 命令:<code>insert into &lt;表名&gt;(字段名1,字段名2,…,字段名n) values(值1,值2,…,值n);</code></p>
<h4 id="删除数据记录"><a href="#删除数据记录" class="headerlink" title="删除数据记录"></a>删除数据记录</h4><p> 命令:<code>delete from 表名 where 表达式;</code></p>
<h4 id="修改数据记录"><a href="#修改数据记录" class="headerlink" title="修改数据记录"></a>修改数据记录</h4><p> 命令:<code>update from 表名 set 字段 = ‘新值’ where 表达式;</code></p>
<h4 id="查询数据记录"><a href="#查询数据记录" class="headerlink" title="查询数据记录"></a>查询数据记录</h4><p> 命令:<code>select * from 表名 (where 表达式) ;</code></p>
<p> 注：对于字段、索引和实例等其他复杂操作在此就不一一介绍了，以上就是在liunx操作mysql常用的命令了。</p>
<p><a href="http://www.cnblogs.com/zhangzhu/archive/2013/07/04/3172486.html" target="_blank" rel="external">其他操作可借鉴</a>  </p>
]]></content>
      
        <categories>
            
            <category> PHP </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql </tag>
            
            <tag> php </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vim的简单使用]]></title>
      <url>/vim%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html/</url>
      <content type="html"><![CDATA[<p>vim是一个类似于vi的著名的功能强大、高度可定制的文本编辑器，在vi的基础上改进和增加了很多特性。vim是自由软件。<br><a id="more"></a><br>其实vim有着很强悍的操作语法，但是在这我只是介绍一些常用能解决文章的基本操作，原因很简单：适合新手！</p>
<h4 id="vi的基本概念"><a href="#vi的基本概念" class="headerlink" title="vi的基本概念"></a>vi的基本概念</h4><p>　　基本上vi可以分为三种状态，分别是命令模式、插入模式和底行模式，各模式的功能区分如下：</p>
<ul>
<li>命令行模式</li>
</ul>
<p>　　控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入插入模式下，<br>或者到底行模式。</p>
<ul>
<li><p>插入模式<br>　　只有在插入模式下，才可以做文字输入，按「ESC」键可回到命令行模式。</p>
</li>
<li><p>底行模式</p>
</li>
</ul>
<p>将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。<br>不过一般我们在使用时把vi简化成两个模式，就是将底行模式也算入命令行模式。</p>
<ul>
<li><p>进命令行模式<br>在进入插入模式后，你只要按[Esc]就可以从插入模式进入命令行模型了。</p>
</li>
<li><p>进入插入模式<br>刚开始打开vim，你必须按i才能进入插入模式。</p>
</li>
<li><p>进入底行模式<br>在使用底行模式之前，请记住先按「ESC」键确定您已经处于命令行模式下后，再按「：」冒号即可进入底行模式。</p>
</li>
</ul>
<h4 id="vim的常规操作"><a href="#vim的常规操作" class="headerlink" title="vim的常规操作"></a>vim的常规操作</h4><ul>
<li>列出行号</li>
</ul>
<p>　「set nu」：输入「set nu」后，会在文件中的每一行前面列出行号。</p>
<ul>
<li>跳到文件中的某一行</li>
</ul>
<p>　「#」：「#」号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，<br>如输入数字15，再回车，就会跳到文章的第15行。</p>
<ul>
<li>查找字符</li>
</ul>
<p>　「/关键字」：先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想<br>要的，可以一直按「n」会往后寻找到您要的关键字为止。</p>
<p>　「?关键字」：先按「?」键，再输入您想寻找的字符，如果第一次找的关键字不是您想<br>要的，可以一直按「n」会往前寻找到您要的关键字为止。</p>
<ul>
<li>保存文件</li>
</ul>
<p>　「w」：在冒号输入字母「w」就可以将文件保存起来。</p>
<ul>
<li><p>保存并退出<br>　按ESC键 跳到命令模式，然后：<br>　:w   保存文件但不退出vi<br>　:w file 将修改另外保存到file中，不退出vi<br>　:w!   强制保存，不推出vi<br>　:wq  保存文件并退出vi（常用）<br>　:wq! 强制保存文件，并退出vi（常用）<br>　q:  不保存文件，退出vi<br>　:q! 不保存文件，强制退出vi<br>　:e! 放弃所有修改，从上次保存文件开始再编辑</p>
</li>
<li><p>离开vi</p>
</li>
</ul>
<p>　「q」：按「q」就是退出，如果无法离开vi，可以在「q」后跟一个「!」强制离开vi。</p>
<p>　「wq」：一般建议离开时，搭配「w」一起使用，这样在退出的时候还可以保存文件。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vim </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git的常规使用]]></title>
      <url>/git%E7%9A%84%E5%B8%B8%E8%A7%84%E4%BD%BF%E7%94%A8.html/</url>
      <content type="html"><![CDATA[<p>首先需要本地git与远程github相连接。采取SSH连接方式。<br>此次教程对于git的使用做一个常规使用的总结，更多高级使用并未涉及。<br><a id="more"></a></p>
<h3 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h3><h4 id="创建ssh-key"><a href="#创建ssh-key" class="headerlink" title="创建ssh key"></a>创建ssh key</h4><p>为了让github能够识别是我们自己上传文件，需要创建ssh key<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ssh-keygen -t rsa -C &quot;your_email@youreamil.com&quot;</div></pre></td></tr></table></figure></p>
<p>这里的your_email@youremail.com是你的邮箱地址，在输入后会询问你是否保存创建的ssh key，点回车就好，然后要求输入你要设置的密码，如果直接回车表示不设密码。然后会提示你ssh key已经创建好。</p>
<h4 id="将ssh写入github"><a href="#将ssh写入github" class="headerlink" title="将ssh写入github"></a>将ssh写入github</h4><p>在windows中生成的id_rsa.pub文件一般在C:\Users\windows用户名\.ssh目录下，打开隐藏文件即可看到。<br>复制出来，在github在点击头像，然后点击setting，在找到SSH and GPG keys，创建一个new ssh key，然后将刚刚复制的ssh key填入即可。</p>
<h4 id="验证是否连接成功"><a href="#验证是否连接成功" class="headerlink" title="验证是否连接成功"></a>验证是否连接成功</h4><p>在终端输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh -T git@github.com</div></pre></td></tr></table></figure></p>
<p>如果回车看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">You’ve successfully authenticated, but GitHub does not provide shell access 。</div></pre></td></tr></table></figure></p>
<p>表示已成功连上github。</p>
<h4 id="设置username和email"><a href="#设置username和email" class="headerlink" title="设置username和email"></a>设置username和email</h4><p>在把本项目上传到github之前还需要分别输入设置username和email，因为github每次commit都会记录他们。所以分别输入如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name &quot;your name&quot;</div><div class="line">$ git config --global user.email &quot;your_email@youremail.com&quot;</div></pre></td></tr></table></figure></p>
<h3 id="以下为后期常用命令"><a href="#以下为后期常用命令" class="headerlink" title="以下为后期常用命令"></a>以下为后期常用命令</h3><h4 id="进入项目，在终端运行"><a href="#进入项目，在终端运行" class="headerlink" title="进入项目，在终端运行"></a>进入项目，在终端运行</h4><p>这是初始化git项目的必须命令，在此路径下会生成一个.git的隐藏文件夹，下面记录着git的一系列相关文件；这是第一步操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git init</div></pre></td></tr></table></figure></p>
<h4 id="添加远程地址"><a href="#添加远程地址" class="headerlink" title="添加远程地址"></a>添加远程地址</h4><p>在与github连接成功后，如何才能让相应的项目上传到对应的仓库呢？这里就需要添加远程地址，从而让我们的本地项目顺利到达对应的仓库。实现远程与本地相连接。</p>
<p>打开终端，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote add origin git@github.com:yourName/yourRepo.git</div></pre></td></tr></table></figure></p>
<h3 id="上传项目"><a href="#上传项目" class="headerlink" title="上传项目"></a>上传项目</h3><h4 id="将远程库与本地库合并"><a href="#将远程库与本地库合并" class="headerlink" title="将远程库与本地库合并"></a>将远程库与本地库合并</h4><p>(注:pull=fetch +merge )：(刚刚添加时本地没有说明文件)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git pull --rebase origin master</div></pre></td></tr></table></figure></p>
<h4 id="然后上传所有"><a href="#然后上传所有" class="headerlink" title="然后上传所有"></a>然后上传所有</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git add .</div></pre></td></tr></table></figure>
<h4 id="添加注释并上传到缓存区"><a href="#添加注释并上传到缓存区" class="headerlink" title="添加注释并上传到缓存区"></a>添加注释并上传到缓存区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m  &apos;本次提交注释&apos;</div></pre></td></tr></table></figure>
<p>提交并上传代码，第一次提交加上’-u’,后面提交可以省略。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push -u origin master</div></pre></td></tr></table></figure></p>
<h3 id="以后提交"><a href="#以后提交" class="headerlink" title="以后提交"></a>以后提交</h3><ul>
<li><p>上传所有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git add .</div></pre></td></tr></table></figure>
</li>
<li><p>添加注释并上传到缓存区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m  &apos;本次提交注释&apos;</div></pre></td></tr></table></figure>
</li>
<li><p>提交并上传代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin master</div></pre></td></tr></table></figure>
</li>
</ul>
<p>如此往复即可。</p>
]]></content>
      
        <categories>
            
            <category> PHP </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[建立博客]]></title>
      <url>/%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2.html/</url>
      <content type="html"><![CDATA[<p>由于诸多原因，我最终选择了hexo+github搭建博客，原因嘛有很多。但是markdown的编写方式和纯命令的编辑方式是我所喜爱的。<br><a id="more"></a><br>我不知道在其他人眼里git意味着什么，但是不知不觉中我觉得我思想发生了一些改变。喜欢上了一些高大上的程序员方式。<br>之前打算用yii2.0搭建博客，但是markdown插件弄了好久都没有弄出来，然后按照yii2.0博客程序也存在弊端；node.js搭建博客弄了弄，使用了Ghost博客程序也不太喜欢，发现英文大多不太喜欢，而且服务器的配置太繁琐，不想hexo几行命令即可搞定。<br>不过我从头到尾都没有想过使用WordPress，原因很简单，没有轻量级的书写方式，不够简洁，我觉得博客的本质应该是写作。<br>专注于写作和学习，这才是我建立博客的主旨。</p>
]]></content>
      
        
    </entry>
    
  
  
</search>
